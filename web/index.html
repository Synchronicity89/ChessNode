<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Chess Engine Minimal UI</title>
  <script src="https://code.jquery.com/jquery-3.7.1.min.js" integrity="sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo=" crossorigin="anonymous"></script>
  <script src="engine-bridge2.js"></script>
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      height: 100vh;
    }

    header {
      padding: 8px 12px;
      background: #222;
      color: #fff;
      font-size: 14px;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    main {
      flex: 1;
      display: flex;
      overflow: hidden;
    }

    .board-area {
      flex: 0 0 auto;
      padding: 12px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .board {
      border: 2px solid #333;
      display: grid;
      grid-template-columns: repeat(8, 64px);
      grid-template-rows: repeat(8, 64px);
      transform-origin: center center;
    }

    .square {
      width: 64px;
      height: 64px;
      display: flex;
      align-items: center;
      justify-content: center;
      box-sizing: border-box;
    }

    .light {
      background: #f0d9b5;
    }

    .dark {
      background: #b58863;
    }

    .square.selected {
      outline: 3px solid #2c7;
    }

    /* Highlights for legal move guidance */
    .square.legal-origin {
      box-shadow: inset 0 0 0 2px rgba(0, 0, 0, 0.35);
    }
    .square.legal-dest {
      box-shadow: inset 0 0 0 3px #06c;
    }

    .panel {
      flex: 1 1 auto;
      padding: 8px 12px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      overflow: auto;
      font-size: 13px;
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }

    .controls label {
      font-size: 12px;
    }

    textarea {
      width: 100%;
      box-sizing: border-box;
      font-family: monospace;
      font-size: 12px;
    }

    #log {
      flex: 1 1 auto;
      border: 1px solid #ccc;
      padding: 4px;
      overflow: auto;
      background: #fafafa;
    }

    #pgn {
      height: 80px;
    }

    #engineIO {
      height: 80px;
    }

    button {
      font-size: 12px;
      padding: 4px 8px;
    }

    .row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
    }

    .mono {
      font-family: monospace;
    }
  </style>
</head>

<body>
  <header>
    <div>Chess Engine Minimal UI</div>
    <div>Engine side: <span id="engineSideLabel" class="mono">white (internal)</span> | Human side: <span
        id="humanSideLabel" class="mono">black (presentation)</span></div>
  </header>
  <main>
    <section class="board-area">
      <div style="margin-bottom:6px; font-size:12px;">Board (bottom: human as black)</div>
      <div id="board" class="board"></div>
      <div class="row" style="margin-top:8px;">
        <button id="btnNewGame">New Game</button>
        <button id="btnFlip">Flip Board</button>
        <button id="btnEngineMove">Engine Move</button>
      </div>
    </section>
    <section class="panel">
      <div class="controls">
        <label>Depth <input id="depth" type="number" value="2" min="1" max="12" style="width:48px;"></label>
        <label>FEN <input id="fenInput" type="text" style="width:100%;" class="mono"
            placeholder="Optional: paste FEN then New Game"></label>
      </div>
      <div>
        <strong>Current Board FEN</strong>
        <input id="fenCurrent" type="text" class="mono" style="width:100%;" readonly>
      </div>
      <div class="row"><strong>Score:</strong> <span id="score" class="mono">--</span></div>
      <div>
        <strong>PGN</strong>
        <textarea id="pgn" readonly></textarea>
      </div>
      <div>
        <strong>Engine I/O (unflipped & flipped)</strong>
        <textarea id="engineIO" readonly></textarea>
      </div>
      <div>
        <strong>Evaluation Explanation</strong>
        <div id="explainSummary" class="mono" style="font-size:12px; min-height:18px; white-space:pre-wrap; border:1px solid #ddd; padding:4px; background:#fdfdfd;"></div>
        <div style="margin:4px 0; display:flex; gap:8px; align-items:center;">
          <button id="btnCopyExplain">Copy Raw JSON</button>
          <span style="font-size:11px; color:#555;">Raw engine explanation payload (read-only)</span>
        </div>
        <textarea id="explainRaw" readonly style="height:140px;"></textarea>
      </div>
      <div>
        <strong>Log</strong>
        <div id="log"></div>
      </div>
      <div>
        <strong>Engine bridge source</strong>
        <div>
          <a id="engineBridgeLink" href="engine-bridge2.js" target="_blank">Open engine-bridge2.js</a>
        </div>
      </div>
    </section>
  </main>
  <script>
    const START_FEN = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';
    const PIECE_IMAGES = {
      'P': 'img/white-pawn.png',
      'N': 'img/white-knight.png',
      'B': 'img/white-bishop.png',
      'R': 'img/white-rook.png',
      'Q': 'img/white-queen.png',
      'K': 'img/white-king.png',
      'p': 'img/black-pawn.png',
      'n': 'img/black-knight.png',
      'b': 'img/black-bishop.png',
      'r': 'img/black-rook.png',
      'q': 'img/black-queen.png',
      'k': 'img/black-king.png'
    };

    let currentFen = START_FEN; // legacy references for existing code paths
    let boardStateFen = START_FEN; // authoritative board state
    let engineIsWhite = true; // set to false to depict engine playing black (communication flipped)
    let humanIsBlack = true; // updated in newGame based on engineIsWhite
    let boardFlipped = true; // visual orientation (bottom side is human)
    let gameMoves = [];
    let debugLogging = false;
    let selectedSquare = null; // algebraic like 'e2'
    let sideToMove = 'w'; // updated from boardStateFen
    let legalHumanMoves = null; // array of board-space UCIs allowed for the human
    let lastEngineExplainRaw = '';

    function updateBoardState(newFen) {
      boardStateFen = newFen;
      currentFen = newFen; // keep older code functional
      syncSideToMoveFromFen();
      renderBoard();
      engineEvaluateFen();
      const $fenCur = $('#fenCurrent');
      if ($fenCur.length) $fenCur.val(boardStateFen);
    }
    
    function isBoardRotated() {
      return !!boardFlipped;
    }

    function syncSideToMoveFromFen() {
      const parts = (boardStateFen || '').split(' ');
      if (parts.length > 1 && (parts[1] === 'w' || parts[1] === 'b')) {
        sideToMove = parts[1];
      }
    }

    function debugCall(name) {
      if (!debugLogging) return;
      console.log('[debug] call:', name);
    }

    function logLine(msg) {
      debugCall('logLine');
      const $log = $('#log');
      if (!$log.length) return;

      const ts = new Date().toISOString().substr(11, 8);
      $('<div>').text('[' + ts + '] ' + msg).appendTo($log);
      $log.scrollTop($log.prop('scrollHeight'));
    }

    function setEngineIO(text) {
      debugCall('setEngineIO');
      const $box = $('#engineIO');
      if (!$box.length) return;

      $box.val(text);
      $box.scrollTop($box.prop('scrollHeight'));
    }

    function updatePgnBox() {
      debugCall('updatePgnBox');
      const $box = $('#pgn');
      if (!$box.length) return;

      let res = '';
      for (let i = 0; i < gameMoves.length; i += 2) {
        const moveNumber = 1 + (i / 2);
        const whiteMove = gameMoves[i] || '';
        const blackMove = gameMoves[i + 1] || '';

        res += moveNumber + '. ' + whiteMove;
        if (blackMove) {
          res += ' ' + blackMove;
        }
        if (i + 2 < gameMoves.length) {
          res += ' ';
        }
      }

      // Append PGN result token if the position is terminal
      try {
        if (window.EngineBridge && typeof window.EngineBridge.detectTerminal === 'function') {
          const term = JSON.parse(window.EngineBridge.detectTerminal(boardStateFen) || '{}');
          let resultToken = '';
          if (term && term.status) {
            if (term.status === 'checkmate') {
              resultToken = term.winner === 'w' ? '1-0' : '0-1';
            } else if (term.status === 'stalemate' || term.status === 'draw-insufficient') {
              resultToken = '1/2-1/2';
            }
          }
          if (resultToken) {
            res = res.trim();
            res = res ? (res + ' ' + resultToken) : resultToken;
          }
        }
      } catch { /* ignore PGN result errors */ }

      $box.val(res.trim());
    }

    function parseBoardArray(fen) {
      debugCall('parseBoardArray');
      const boardPart = (fen || '').split(' ')[0] || '';
      const rows = boardPart.split('/');
      const grid = Array.from({ length: 8 }, () => Array(8).fill('.'));

      for (let r = 0; r < 8 && r < rows.length; r++) {
        let c = 0;
        for (const ch of rows[r]) {
          if (/^[1-8]$/.test(ch)) {
            c += parseInt(ch, 10);
          } else {
            if (c < 8) grid[r][c++] = ch;
          }
        }
      }

      return grid;
    }

    function flipFenString(fen) {
      debugCall('flipFenString');
      try {
        const parts = (fen || '').trim().split(/\s+/);
        if (parts.length < 6) return fen;

        const placement = parts[0];
        const side = parts[1];
        const cast = parts[2];
        const ep = parts[3];
        const half = parts[4];
        const full = parts[5];

        const ranks = placement.split('/');
        if (ranks.length !== 8) return fen;

        const squares = new Array(64).fill('.');
        for (let r = 0; r < 8; r++) {
          let file = 0;
          for (const ch of ranks[r]) {
            if (/^[1-8]$/.test(ch)) {
              const n = parseInt(ch, 10);
              for (let k = 0; k < n; k++) {
                squares[r * 8 + file] = '.';
                file++;
              }
            } else {
              squares[r * 8 + file] = ch;
              file++;
            }
          }
          if (file !== 8) return fen;
        }

        const out = new Array(64).fill('.');
        for (let i = 0; i < 64; i++) {
          let p = squares[i];
          const j = 63 - i;
          if (p !== '.') {
            const upper = p.toUpperCase();
            const lower = p.toLowerCase();
            p = (p === upper) ? lower : upper;
          }
          out[j] = p;
        }

        const rowsOut = [];
        for (let r = 0; r < 8; r++) {
          let row = '';
          let empty = 0;
          for (let c = 0; c < 8; c++) {
            const p = out[r * 8 + c];
            if (p === '.') {
              empty++;
            } else {
              if (empty) {
                row += String(empty);
                empty = 0;
              }
              row += p;
            }
          }
          if (empty) row += String(empty);
          rowsOut.push(row);
        }

        const newPlacement = rowsOut.join('/');
        const newSide = (side === 'w') ? 'b' : 'w';

        const has = { K: false, Q: false, k: false, q: false };
        for (const ch of (cast || '')) {
          if (has.hasOwnProperty(ch)) has[ch] = true;
        }
        const newCast = (has.k ? 'K' : '') + (has.q ? 'Q' : '') + (has.K ? 'k' : '') + (has.Q ? 'q' : '');
        const castOut = newCast || '-';

        let epOut = '-';
        if (ep && ep.length === 2 && /^[a-h][1-8]$/.test(ep)) {
          const f = ep.charCodeAt(0) - 97;
          const r = ep.charCodeAt(1) - 49;
          const nf = 7 - f;
          const nr = 7 - r;
          epOut = String.fromCharCode(97 + nf) + String.fromCharCode(49 + nr);
        }

        return `${newPlacement} ${newSide} ${castOut} ${epOut} ${half} ${full}`;
      } catch {
        return fen;
      }
    }

    function flipSquare180(alg) {
      debugCall('flipSquare180');
      if (!alg || alg.length !== 2) return alg;
      const f = alg.charCodeAt(0) - 97;
      const r = alg.charCodeAt(1) - 49;
      if (f < 0 || f > 7 || r < 0 || r > 7) return alg;
      const nf = 7 - f;
      const nr = 7 - r;
      return String.fromCharCode(97 + nf) + String.fromCharCode(49 + nr);
    }

    function flipMoveUci180(uci) {
      debugCall('flipMoveUci180');
      if (!uci || uci.length < 4) return uci;
      const from = uci.slice(0, 2);
      const to = uci.slice(2, 4);
      const promo = uci.length > 4 ? uci.slice(4) : '';
      return flipSquare180(from) + flipSquare180(to) + promo;
    }

    function renderBoard() {
      debugCall('renderBoard');

      const $board = $('#board');
      if (!$board.length) return;

      $board.empty();
      $board.css('transform', boardFlipped ? 'rotate(180deg)' : 'none');
      // Expose current rotation for tests and debugging: '0' or '180'.
      $board.attr('data-rotated', boardFlipped ? '180' : '0');

      const grid = parseBoardArray(currentFen);

      // Precompute legal move highlighting sets
      const humanColor = engineIsWhite ? 'b' : 'w';
      const hasLegals = Array.isArray(legalHumanMoves) && legalHumanMoves.length > 0 && sideToMove === humanColor;
      const originSet = new Set();
      const destSet = new Set();
      if (hasLegals) {
        for (const u of legalHumanMoves) {
          const f = u.slice(0,2), t = u.slice(2,4);
          originSet.add(f);
          if (selectedSquare && f === selectedSquare) destSet.add(t);
        }
      }

      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          const $div = $('<div class="square">');
          $div.addClass(((r + c) % 2) ? 'dark' : 'light');

          // Map visual square to algebraic (taking boardFlipped into account)
          const fileIdx = boardFlipped ? 7 - c : c;
          const rankIdx = boardFlipped ? r : 7 - r;
          const fileChar = String.fromCharCode(97 + fileIdx);
          const rankChar = String.fromCharCode(49 + rankIdx);
          const sq = fileChar + rankChar;
          $div.data('sq', sq);
          // Also persist as an HTML data-* attribute so non-jQuery callers (e.g., tests)
          // can reliably query by square without needing jQuery's internal data store.
          $div.attr('data-sq', sq);

          if (selectedSquare === sq) {
            $div.addClass('selected');
          }

          if (hasLegals) {
            if (originSet.has(sq)) $div.addClass('legal-origin');
            if (destSet.has(sq)) $div.addClass('legal-dest');
          }

          const piece = grid[r][c];
          if (piece && piece !== '.') {
            const isWhite = (piece === piece.toUpperCase());
            const $img = $('<img>', {
              src: PIECE_IMAGES[piece] || '',
              alt: piece
            }).css({
              width: '56px',
              height: '56px'
            }).prop('draggable', false);
            // Expose test-friendly attributes so headless tests can
            // easily introspect the board state.
            $div.attr('data-piece', piece);
            $div.attr('data-color', isWhite ? 'white' : 'black');
            $div.append($img);
          } else {
            // Ensure empty squares do not carry stale metadata
            $div.removeAttr('data-piece');
            $div.removeAttr('data-color');
          }

          $board.append($div);
        }
      }

      // Defensive: ensure piece metadata exists even if image append path was skipped.
      try {
        const placement = (currentFen || '').split(' ')[0] || '';
        function getPieceAt(sq){
          const rows = placement.split('/');
          if (rows.length!==8) return '.';
          const f=sq.charCodeAt(0)-97; const r=sq.charCodeAt(1)-49; if(f<0||f>7||r<0||r>7) return '.';
          const rr=7-r; let cc=0; for(const ch of rows[rr]){ if(/^[1-8]$/.test(ch)){ cc+=parseInt(ch,10);} else { if(cc===f) return ch; cc++; } }
          return '.';
        }
        $board.children('.square').each(function(){
          const el = $(this);
          if (el.attr('data-color')) return;
          const sq = el.data('sq');
          if (!sq) return;
          const p = getPieceAt(sq);
          if (p && p!=='.') {
            el.attr('data-piece', p);
            el.attr('data-color', (p===p.toUpperCase()) ? 'white' : 'black');
          }
        });
      } catch {}
    }

    function simpleSanFromUci(uci, fenBefore) {
      debugCall('simpleSanFromUci');
      if (!uci || uci.length < 4) return uci || '';
      try {
        const fen = fenBefore || boardStateFen;
        const placement = (fen || '').split(' ')[0] || '';
        const rows = placement.split('/');
        if (rows.length !== 8) return uci;
        const board = Array.from({ length: 8 }, () => Array(8).fill('.'));
        for (let r = 0; r < 8; r++) {
          let c = 0;
          for (const ch of rows[r]) {
            if (/^[1-8]$/.test(ch)) c += parseInt(ch, 10);
            else if (c < 8) board[r][c++] = ch;
          }
        }
        const from = uci.slice(0, 2);
        const file = from.charCodeAt(0) - 97;
        const rank = from.charCodeAt(1) - 49;
        if (file < 0 || file > 7 || rank < 0 || rank > 7) return uci;
        const rr = 7 - rank;
        const cc = file;
        const piece = board[rr][cc];
        if (!piece || piece === '.' || piece.toLowerCase() === 'p') return uci;
        return piece.toUpperCase() + uci;
      } catch {
        return uci;
      }
    }

    function updateScore(cp) {
      debugCall('updateScore');

      const $score = $('#score');
      if (!$score.length) return;

      if (cp === null || cp === undefined) {
        $score.text('--');
        return;
      }

      const pawns = (cp / 100).toFixed(2);
      $score.text((cp >= 0 ? '+' : '') + pawns);
    }

    function engineEvaluateFen() {
      debugCall('engineEvaluateFen');
      if (!window.EngineBridge) return;
      let cp = null;
      if (window.EngineBridge.evaluateFEN) {
        cp = window.EngineBridge.evaluateFEN(boardStateFen);
      }
      updateScore(cp);

      // Also keep Engine I/O box roughly in sync after arbitrary FEN changes
      let ioText = '';
      ioText += 'fen (original board): ' + boardStateFen + '\n';
      ioText += '\n[explain.math]\n';
      ioText += 'Stub evaluation: material-only score ' + (cp !== null ? cp + ' cp' : 'n/a') + '.\n';
      setEngineIO(ioText);
    }

    function engineChooseBestMove() {
      debugCall('engineChooseBestMove');
      if (!window.EngineBridge || !window.EngineBridge.chooseBestMove) {
        logLine('Engine chooseBestMove not available');
        return;
      }

      const depth = parseInt($('#depth').val(), 10) || 2;
      const optsJson = JSON.stringify({ searchDepth: depth });
      const stm = boardStateFen.split(' ')[1];
      // Turn validation depending on engine color
      if (engineIsWhite && stm !== 'w') {
        logLine('ERROR: Engine Move pressed but it is not white to move.');
        return;
      }
      if (!engineIsWhite && stm !== 'b') {
        logLine('ERROR: Engine Move pressed but it is not black to move.');
        return;
      }
      const flipComm = !engineIsWhite; // flip inbound/outbound when engine plays black
      const fenForEngine = flipComm ? flipFenString(boardStateFen) : boardStateFen;

      logLine('ENGINE (white) MOVE REQUEST: chooseBestMove');
      logLine('  fen (board->engine): ' + fenForEngine);
      logLine('  options: ' + optsJson);

      const t0 = performance.now();
      const res = window.EngineBridge.chooseBestMove(fenForEngine, optsJson);
      const t1 = performance.now();

      if (!res) {
        logLine('ENGINE ERROR: null response from chooseBestMove');
        return;
      }

      logLine('ENGINE RESPONSE RAW: ' + res);

      let obj = null;
      try {
        obj = JSON.parse(res);
      } catch (e) {
        logLine('ENGINE PARSE ERROR: ' + e);
        return;
      }

      let engineUci = obj && obj.best && obj.best.uci ? obj.best.uci : null;
      if (!engineUci) {
        logLine('ENGINE RESULT: missing best.uci');
        return;
      }
      // If communication flipped (engine playing black), flip move back to board space
      const boardUci = flipComm ? flipMoveUci180(engineUci) : engineUci;

      let ioText = '';
      ioText += 'fen (original board): ' + boardStateFen + '\n';
      ioText += 'fen sent to engine : ' + fenForEngine + '\n';
      ioText += 'engine best uci    : ' + engineUci + '\n';
      ioText += 'board-applied uci  : ' + boardUci + '\n';
      if (obj.status) {
        ioText += 'status             : ' + obj.status + '\n';
      }
      if (obj.explain && obj.explain.math) {
        ioText += '\n[explain.math]\n' + obj.explain.math + '\n';
      }
      setEngineIO(ioText);

      // Store and display explanation summary + raw JSON
      lastEngineExplainRaw = res;
      updateExplanationBoxes(obj, res);

      const nodesInfo = (typeof obj.nodesTotal === 'number') ? ', nodes=' + obj.nodesTotal : '';
      const depthInfo = (typeof obj.depth === 'number') ? ', depth=' + obj.depth : '';
      const scoreInfo = (obj.best && typeof obj.best.score === 'number') ? ', score=' + obj.best.score + ' cp' : '';
      logLine('ENGINE (white) RESULT: best=' + engineUci + ' (board=' + boardUci + ')' + scoreInfo + depthInfo + nodesInfo + ' in ' + (t1 - t0).toFixed(1) + ' ms');

      // Compute move token using pre-move FEN so piece detection is correct
      const san = simpleSanFromUci(boardUci, boardStateFen);
      const nextFen = fenApplyUciMove(boardStateFen, boardUci);
      if (!nextFen) {
        logLine('ENGINE MOVE APPLY FAILED for uci=' + boardUci);
        return;
      }
      updateBoardState(nextFen);
      // Store moves as sequential halfmoves (always push)
      gameMoves.push(san);
      updatePgnBox();

      // After engine moves, compute legal human moves (2-ply prune)
      requestHumanLegalMoves2Ply();
    }

    function tryHumanMove(fromSq, toSq, evtOrOpts) {
      debugCall('tryHumanMove');
      if (!fromSq || !toSq || fromSq === toSq) return;
      syncSideToMoveFromFen();
      const humanColor = engineIsWhite ? 'b' : 'w';
      if (sideToMove !== humanColor) {
        logLine('Human move ignored: not ' + (humanColor === 'w' ? 'white' : 'black') + " to move.");
        return;
      }
      // Require known legals and enforce membership
      if (!Array.isArray(legalHumanMoves) || legalHumanMoves.length === 0) {
        logLine('Awaiting legal moves; please wait.');
        return;
      }
      let uciPresentation = fromSq + toSq; // based on provided squares
      // Prefer matching whatever space matches the known legal set: when the board is rotated,
      // try flipped (board-space) first, but also allow raw presentation-space if it matches.
      const uciFlipped = flipMoveUci180(uciPresentation);
      const prefer = isBoardRotated() ? [uciFlipped, uciPresentation] : [uciPresentation, uciFlipped];
      let uci = prefer[0];
      // Diagnostic: show move candidates and current legal set head
      try {
        const head = (legalHumanMoves || []).slice(0, 12).join(' ');
        logLine('HUMAN candidate(s): ' + prefer.join(' | ') + ' | legals[0..11]: ' + head);
      } catch {}
      // Promotion handling: if pawn reaches last rank, append promotion piece (default 'q').
      try {
        const ctrlHeld = !!(evtOrOpts && (evtOrOpts.ctrlKey || evtOrOpts.ctrl));
        const placement = (boardStateFen || '').split(' ')[0] || '';
        function getPieceAt(sq){
          const rows = placement.split('/');
          if (rows.length!==8) return '.';
          const f=sq.charCodeAt(0)-97; const r=sq.charCodeAt(1)-49; if(f<0||f>7||r<0||r>7) return '.';
          const rr=7-r; let cc=0; for(const ch of rows[rr]){ if(/^[1-8]$/.test(ch)){ cc+=parseInt(ch,10);} else { if(cc===f) return ch; cc++; } }
          return '.';
        }
        const from = uci.slice(0,2), to = uci.slice(2,4);
        const mover = getPieceAt(from);
        const isPawn = mover && mover.toLowerCase()==='p';
        const toRankNum = (to.charCodeAt(1)-49)+1; // 1..8
        const isWhitePawn = mover === mover.toUpperCase();
        const reachesLast = isPawn && ((isWhitePawn && toRankNum===8) || (!isWhitePawn && toRankNum===1));
        if (reachesLast) {
          let promo = 'q';
          if (ctrlHeld) {
            const choice = (prompt('Promote to (q,r,b,n)?','q') || 'q').trim().toLowerCase();
            if (/^[qrbn]$/.test(choice)) promo = choice;
          }
          uci += promo;
        }
      } catch {}
      logLine('HUMAN (' + (humanColor === 'w' ? 'white' : 'black') + ') MOVE REQUEST: ' + uciPresentation + ' (board-candidate=' + uci + ')');
      if (!legalHumanMoves.includes(uci)) {
        // Try alternate candidate if first choice not legal
        const alt = prefer[1];
        logLine('HUMAN move not in legals, trying alt: ' + alt);
        if (legalHumanMoves.includes(alt)) {
          uci = alt;
        }
      }
      if (!legalHumanMoves.includes(uci)) {
        // Extra diagnostics to understand mismatches
        try {
          const sample = (legalHumanMoves || []).slice(0, 20).join(' ');
          logLine('ILLEGAL move rejected: ' + uci + ' (not in legal set). Sample legals: ' + sample);
        } catch {
          logLine('ILLEGAL move rejected: ' + uci + ' (not in legal set)');
        }

        // HACK fallback: Re-query engine legals directly and, if intended move is legal,
        // force-apply the result by updating the FEN input and advancing the board state
        // so the game can continue. Users will only notice the FEN text changing.
        try {
          if (window.EngineBridge && window.EngineBridge.listLegalMoves2Ply) {
            const humanColor = engineIsWhite ? 'b' : 'w';
            const flipComm = engineIsWhite; // human presented as white to engine when engine is white
            const fenForEngine = flipComm ? flipFenString(boardStateFen) : boardStateFen;
            const res = window.EngineBridge.listLegalMoves2Ply(fenForEngine, JSON.stringify({ ply: 2 }));
            let obj = null; try { obj = JSON.parse(res); } catch {}
            const rawMoves = (obj && Array.isArray(obj.moves)) ? obj.moves : [];
            const boardMoves = flipComm ? rawMoves.map(flipMoveUci180) : rawMoves.slice();
            // Prefer board-space intended move first
            const intended = prefer[0];
            const alt2 = prefer[1];
            const chosen = boardMoves.includes(intended) ? intended : (boardMoves.includes(alt2) ? alt2 : null);
            if (chosen) {
              const san = simpleSanFromUci(chosen, boardStateFen);
              const nextFen = fenApplyUciMove(boardStateFen, chosen);
              if (nextFen) {
                // Reflect change in FEN input so it's visible to users, then advance board
                const $fenInput = $('#fenInput'); if ($fenInput.length) $fenInput.val(nextFen);
                updateBoardState(nextFen);
                selectedSquare = null;
                gameMoves.push(san);
                updatePgnBox();
                logLine('FALLBACK: Forced apply of legal move ' + chosen + ' after UI mismatch.');
                // Precompute next legals for the human if still their turn
                requestHumanLegalMoves2Ply();
                return;
              }
            }
          }
        } catch {}
        renderBoard();
        return;
      }
      // Compute move token using pre-move FEN so piece detection is correct
      const san = simpleSanFromUci(uci, boardStateFen);
      const nextFen = fenApplyUciMove(boardStateFen, uci);
      if (!nextFen) {
        logLine('HUMAN MOVE APPLY FAILED for uci=' + uci);
        return;
      }
      updateBoardState(nextFen);
      selectedSquare = null;
      // Clear legals until engine replies and we recompute
      legalHumanMoves = null;
      // Always push halfmove
      gameMoves.push(san);
      updatePgnBox();
    }

    function newGame() {
      debugCall('newGame');

      const fenText = ($('#fenInput').val() || '').toString().trim() || START_FEN;
      boardFlipped = engineIsWhite; // bottom side is human color
      humanIsBlack = engineIsWhite; // if engine plays black, human is white
      gameMoves = [];
      $('#humanSideLabel').text(engineIsWhite ? 'black (presentation)' : 'white (presentation)');

      selectedSquare = null;
      updateBoardState(fenText);
      updatePgnBox();
      setEngineIO('');

      // If human starts, precompute legal moves
      syncSideToMoveFromFen();
      const humanColor = engineIsWhite ? 'b' : 'w';
      if (sideToMove === humanColor) {
        requestHumanLegalMoves2Ply();
      }

      const $imgs = $('#board img');
      if ($imgs.length === 0) {
        console.error('New Game: renderBoard completed but no piece images were found under #board.');
        console.error('Check that PIECE_IMAGES paths are correct and that currentFen has pieces in the placement field.');
      }

      logLine('New game started. Engine plays ' + (engineIsWhite ? 'white' : 'black') + '; human plays ' + (engineIsWhite ? 'black' : 'white') + ' at bottom.');
    }

    function flipBoardOnly() {
      debugCall('flipBoardOnly');
      boardFlipped = !boardFlipped;
      renderBoard();
      logLine('Board visual flipped 180 degrees.');
    }

    function init() {
      debugCall('init');

      if (window.EngineBridge && window.EngineBridge.setRandomSeed) {
        try {
          window.EngineBridge.setRandomSeed(12345);
          logLine('Engine RNG seed set to 12345');
        } catch {
        }
      }

      $('#btnNewGame').on('click', function () {
        debugCall('btnNewGame.click');
        newGame();
      });
      $('#btnFlip').on('click', function () {
        debugCall('btnFlip.click');
        flipBoardOnly();
      });
      $('#btnEngineMove').on('click', function () {
        debugCall('btnEngineMove.click');
        engineChooseBestMove();
      });

      // Click-to-move handler for human moves
      $('#board').on('click', '.square', function (evt) {
        debugCall('board.square.click');
        const sq = $(this).data('sq');
        if (!sq) return;

        // Do not allow destination selection until legals are known
        const humanColor = engineIsWhite ? 'b' : 'w';
        if (sideToMove === humanColor) {
          if (!Array.isArray(legalHumanMoves) || legalHumanMoves.length === 0) {
            // if missing, request them now
            requestHumanLegalMoves2Ply();
            logLine('Awaiting legal moves; click again once highlighted.');
            return;
          }
        }

        // Determine if clicked square contains a human piece
        const clickedColor = ($(this).attr('data-color') || '').toLowerCase();
        const humanColorWord = humanIsBlack ? 'black' : 'white';
        const isHumanPiece = clickedColor === humanColorWord;

        if (!selectedSquare) {
          // Only start selection on a human piece
          if (isHumanPiece) {
            selectedSquare = sq;
            renderBoard();
          }
          return;
        }

        // If clicking the same square, clear selection
        if (sq === selectedSquare) {
          selectedSquare = null;
          renderBoard();
          return;
        }

        // If clicking another human piece while a selection is active, switch selection
        if (isHumanPiece) {
          selectedSquare = sq;
          renderBoard();
          return;
        }

        // Otherwise, attempt move from selected to clicked square
        const fromSq = selectedSquare;
        const toSq = sq;
        selectedSquare = null;
        tryHumanMove(fromSq, toSq, evt);
      });

      newGame();
    }

    // Test/automation helper: perform a human move by ensuring legals are computed
    // and invoking the same pathway as click-to-move. Returns the updated FEN
    // string on success, or the original FEN if the move was rejected.
    function performHumanClickMove(fromSq, toSq, evtOrOpts) {
      try {
        debugCall('performHumanClickMove');
        // If legals aren't computed yet (e.g., new FEN just loaded), get them now.
        if (!Array.isArray(legalHumanMoves) || legalHumanMoves.length === 0) {
          requestHumanLegalMoves2Ply();
        }
        const fenBefore = boardStateFen;
        tryHumanMove(fromSq, toSq, evtOrOpts);
        return boardStateFen;
      } catch {
        return boardStateFen;
      }
    }

    $(function () {
      const params = new URLSearchParams(window.location.search);
      debugLogging = params.get('debug') === 'true';
      if (debugLogging) {
        console.log('[debug] query param debug=true detected; enabling call logging');
      }

      debugCall('document.ready');

      // Basic runtime checks that required assets and APIs are present.
      // Skip asset checks under JSDOM test environment.
      if (!window.JSDOM_TEST_ENV) {
        const missing = [];
        $.ajax({
          url: 'engine-bridge2.js',
          method: 'HEAD'
        }).fail(function () {
          missing.push('engine-bridge2.js (bridge JS file not found)');
          console.error('Asset check: engine-bridge2.js is not reachable from this page.');
        }).always(function () {
          const hasEngineBridge = !!window.EngineBridge;
          if (!hasEngineBridge) {
            missing.push('window.EngineBridge (bridge object not defined)');
            console.error('Asset check: window.EngineBridge is not defined.');
          }

          const hasWasmModule = hasEngineBridge && !!window.EngineBridge.wasmModule;
          if (!hasWasmModule) {
            console.warn('Asset check: EngineBridge.wasmModule is missing; WASM may not be loaded yet.');
          }

          if (missing.length) {
            logLine('ASSET CHECK FAILED: ' + missing.join('; '));
          } else {
            logLine('ASSET CHECK OK: engine bridge JS reachable; EngineBridge object present.');
          }
        });
      }

      if (window.EngineBridge && window.EngineBridge.wasmReady) {
        init();
      } else {
        $(window).one('engine-bridge-ready', function () {
          debugCall('engine-bridge-ready');
          init();
        });
      }
    });

    // Expose selected helpers for tests/automation
    window.performHumanClickMove = performHumanClickMove;

    function updateExplanationBoxes(obj, raw) {
      debugCall('updateExplanationBoxes');
      const $sum = $('#explainSummary');
      const $raw = $('#explainRaw');
      if (!$sum.length || !$raw.length) return;
      let summary = 'n/a';
      if (obj && obj.explain && typeof obj.explain.math === 'string') {
        summary = obj.explain.math.trim();
      }
      if (obj && obj.status && obj.status !== 'ok') {
        summary = ('status=' + obj.status + ' | ') + summary;
      }
      $sum.text(summary);
      $raw.val(raw);
    }

    $(document).on('click', '#btnCopyExplain', function () {
      debugCall('btnCopyExplain.click');
      const raw = $('#explainRaw').val() || '';
      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(raw).then(() => {
          logLine('Explanation JSON copied to clipboard.');
        }).catch(() => {
          fallbackCopy(raw);
        });
      } else {
        fallbackCopy(raw);
      }
      function fallbackCopy(text) {
        const ta = document.createElement('textarea');
        ta.value = text;
        ta.style.position = 'fixed';
        ta.style.top = '-1000px';
        document.body.appendChild(ta);
        ta.select();
        try { document.execCommand('copy'); logLine('Explanation JSON copied (fallback).'); } catch (e) { logLine('Copy failed: ' + e); }
        document.body.removeChild(ta);
      }
    });

    function requestHumanLegalMoves2Ply() {
      debugCall('requestHumanLegalMoves2Ply');
      if (!window.EngineBridge || !window.EngineBridge.listLegalMoves2Ply) return;
      syncSideToMoveFromFen();
      const humanColor = engineIsWhite ? 'b' : 'w';
      if (sideToMove !== humanColor) return; // Only compute when it's human turn
      const flipComm = engineIsWhite; // when engine depicted white, flip to make human side appear white to engine
      const fenForEngine = flipComm ? flipFenString(boardStateFen) : boardStateFen;
      const t0 = performance.now();
      const res = window.EngineBridge.listLegalMoves2Ply(fenForEngine, JSON.stringify({ ply: 2 }));
      const t1 = performance.now();
      let obj = null;
      try { obj = JSON.parse(res); } catch { obj = null; }
      if (!obj || !Array.isArray(obj.moves)) {
        logLine('LEGAL MOVES ERROR: could not parse engine response');
        return;
      }
      // Flip moves back to board space if needed
      const rawMoves = obj.moves || [];
      legalHumanMoves = flipComm ? rawMoves.map(flipMoveUci180) : rawMoves.slice();
      logLine('Legal moves ready: ' + legalHumanMoves.length + ' moves (computed in ' + (t1 - t0).toFixed(1) + ' ms)');
      try {
        const sample = (legalHumanMoves || []).slice(0, 20).join(' ');
        logLine('Legal (board-space) sample: ' + sample);
      } catch {}
      renderBoard();
    }

    // General-purpose FEN move applier (basic: no legality, no captures accounting beyond placement change)
    function fenApplyUciMove(fen, uci) {
      try {
        if (!fen || !uci || uci.length < 4) return null;
        const parts = fen.trim().split(/\s+/);
        if (parts.length < 6) return null;
        const placement = parts[0];
        const side = parts[1];
        const cast = parts[2];
        const ep = parts[3];
        const half = parts[4];
        let full = parseInt(parts[5], 10) || 1;
        const from = uci.slice(0,2);
        const to = uci.slice(2,4);
        const promo = uci.length > 4 ? uci.slice(4) : '';
        function sqToCoords(sq){ if(!sq||sq.length!==2) return null; const f=sq.charCodeAt(0)-97; const r=sq.charCodeAt(1)-49; if(f<0||f>7||r<0||r>7) return null; return {r:7-r,c:f}; }
        function parseBoard(p){ const ranks=p.split('/'); const b=Array.from({length:8},()=>Array(8).fill('.')); for(let rr=0; rr<8; rr++){ let cc=0; for(const ch of ranks[rr]){ if(/^[1-8]$/.test(ch)){ cc+=parseInt(ch,10);} else { if(cc<8) b[rr][cc++]=ch; } } } return b; }
        function encodeBoard(b){ const out=[]; for(let rr=0; rr<8; rr++){ let row=''; let empty=0; for(let cc=0; cc<8; cc++){ const p=b[rr][cc]; if(p==='.') empty++; else { if(empty){ row+=String(empty); empty=0;} row+=p; } } if(empty) row+=String(empty); out.push(row);} return out.join('/'); }
        const board=parseBoard(placement);
        const fromC=sqToCoords(from); const toC=sqToCoords(to);
        if(!fromC||!toC) return null;
        const piece=board[fromC.r][fromC.c]; if(piece==='.') return null;
        board[toC.r][toC.c]= promo ? (side==='w'?promo.toUpperCase():promo.toLowerCase()): piece;
        board[fromC.r][fromC.c]='.';
        const newPlacement=encodeBoard(board);
        const newSide = side==='w' ? 'b':'w';
        if(side==='b') full += 1; // increment after black move
        return `${newPlacement} ${newSide} ${cast} - ${half} ${full}`;
      } catch(e){ logLine('fenApplyUciMove error: '+e); return null; }
    }
  </script>
</body>

</html>