<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Chess Engine Minimal UI</title>
  <script src="https://code.jquery.com/jquery-3.7.1.min.js" integrity="sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo=" crossorigin="anonymous"></script>
  <script src="engine-bridge2.js"></script>
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      height: 100vh;
    }

    header {
      padding: 8px 12px;
      background: #222;
      color: #fff;
      font-size: 14px;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    main {
      flex: 1;
      display: flex;
      overflow: hidden;
    }

    .board-area {
      flex: 0 0 auto;
      padding: 12px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .board {
      border: 2px solid #333;
      display: grid;
      grid-template-columns: repeat(8, 64px);
      grid-template-rows: repeat(8, 64px);
    }

    .square {
      width: 64px;
      height: 64px;
      display: flex;
      align-items: center;
      justify-content: center;
      box-sizing: border-box;
      position: relative;
    }

    .light {
      background: #f0d9b5;
    }

    .dark {
      background: #b58863;
    }

    .square.selected {
      outline: 3px solid #2c7;
    }

    /* Highlights for legal move guidance */
    .square.legal-origin {
      box-shadow: inset 0 0 0 2px rgba(0, 0, 0, 0.35);
    }
    .square.legal-dest {
      box-shadow: inset 0 0 0 3px #06c;
    }

    /* Small algebraic coordinate badge in each square */
    .sq-label {
      position: absolute;
      top: 2px;
      left: 4px;
      font-size: 10px;
      line-height: 10px;
      color: rgba(0,0,0,0.55);
      user-select: none;
      pointer-events: none;
      z-index: 1;
      text-shadow: 0 1px 0 rgba(255,255,255,0.4);
    }

    .panel {
      flex: 1 1 auto;
      padding: 8px 12px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      overflow: auto;
      font-size: 13px;
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }

    .controls label {
      font-size: 12px;
    }

    textarea {
      width: 100%;
      box-sizing: border-box;
      font-family: monospace;
      font-size: 12px;
    }

    #log {
      flex: 1 1 auto;
      border: 1px solid #ccc;
      padding: 4px;
      overflow: auto;
      background: #fafafa;
    }

    #pgn {
      height: 80px;
    }

    #engineIO {
      height: 80px;
    }

    button {
      font-size: 12px;
      padding: 4px 8px;
    }

    .row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
    }

    .mono {
      font-family: monospace;
    }
  </style>
</head>

<body>
  <header>
    <div>Chess Engine Minimal UI</div>
    <div>Engine side: <span id="engineSideLabel" class="mono">white (internal)</span> | Human side: <span
        id="humanSideLabel" class="mono">black (presentation)</span></div>
  </header>
  <main>
    <section class="board-area">
      <div style="margin-bottom:6px; font-size:12px;">Board (bottom: human as black)</div>
      <div id="board" class="board"></div>
      <div class="row" style="margin-top:8px;">
        <button id="btnNewGame">New Game</button>
        <button id="btnFlip">Flip Board</button>
        <button id="btnEngineMove">Engine Move</button>
      </div>
    </section>
    <section class="panel">
      <div class="controls">
        <label>Mode
          <select id="variantSelect">
            <option value="standard">Standard</option>
            <option value="chess960">Chess960</option>
          </select>
        </label>
        <button id="btnRandom960" disabled>Randomize 960</button>
        <button id="btnStdCastle">Std Castle Test</button>
        <label>Depth <input id="depth" type="number" value="2" min="1" max="12" style="width:48px;"></label>
        <label>FEN
          <textarea id="fenInput" class="mono" rows="2" style="width:100%; resize: vertical;"
            placeholder="Optional: paste FEN then New Game"></textarea>
        </label>
      </div>
      <div style="border:1px solid #e5b800; background:#fffbe6; padding:8px; border-radius:4px;">
        <strong>Workaround: Type Human Move</strong>
        <div style="font-size:12px; color:#555; margin:4px 0;">
          If clicking a piece doesn't work, type your move and press Apply.
          Use the square labels you see on the board (e.g., <code>d5d4</code>),
          add a promotion letter if needed (e.g., <code>e2e1q</code>).
        </div>
        <div class="row">
          <input id="humanMoveInput" type="text" class="mono" style="width:140px;" placeholder="e.g., d5d4">
          <button id="btnHumanMoveApply">Apply Human Move</button>
        </div>
      </div>
      <div>
        <strong>Current Board FEN</strong>
        <input id="fenCurrent" type="text" class="mono" style="width:100%;" readonly>
      </div>
      <div class="row"><strong>Score:</strong> <span id="score" class="mono">--</span></div>
      <div>
        <strong>PGN</strong>
        <textarea id="pgn" readonly></textarea>
      </div>
      <div>
        <strong>Engine I/O (unflipped & flipped)</strong>
        <textarea id="engineIO" readonly></textarea>
      </div>
      <div>
        <strong>Evaluation Explanation</strong>
        <div id="explainSummary" class="mono" style="font-size:12px; min-height:18px; white-space:pre-wrap; border:1px solid #ddd; padding:4px; background:#fdfdfd;"></div>
        <div style="margin:4px 0; display:flex; gap:8px; align-items:center;">
          <button id="btnCopyExplain">Copy Raw JSON</button>
          <span style="font-size:11px; color:#555;">Raw engine explanation payload (read-only)</span>
        </div>
        <textarea id="explainRaw" readonly style="height:140px;"></textarea>
      </div>
      <div>
        <strong>Log</strong>
        <div id="log"></div>
      </div>
      <div>
        <strong>Engine bridge source</strong>
        <div>
          <a id="engineBridgeLink" href="engine-bridge2.js" target="_blank">Open engine-bridge2.js</a>
        </div>
      </div>
    </section>
  </main>
  <script>
    const START_FEN = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';
    const PIECE_IMAGES = {
      'P': 'img/white-pawn.png',
      'N': 'img/white-knight.png',
      'B': 'img/white-bishop.png',
      'R': 'img/white-rook.png',
      'Q': 'img/white-queen.png',
      'K': 'img/white-king.png',
      'p': 'img/black-pawn.png',
      'n': 'img/black-knight.png',
      'b': 'img/black-bishop.png',
      'r': 'img/black-rook.png',
      'q': 'img/black-queen.png',
      'k': 'img/black-king.png'
    };

    let currentFen = START_FEN; // legacy references for existing code paths
    let boardStateFen = START_FEN; // authoritative board state
    let engineIsWhite = true; // set to false to depict engine playing black (communication flipped)
    let humanIsBlack = true; // updated in newGame based on engineIsWhite
    let boardFlipped = true; // visual orientation (bottom side is human)
    let gameMoves = [];
    let debugLogging = false;
    let selectedSquare = null; // algebraic like 'e2'
    let sideToMove = 'w'; // updated from boardStateFen
    let legalHumanMoves = null; // array of board-space UCIs allowed for the human
    let chess960CastleMoves = {}; // king square -> { kingside: 'uci', queenside: 'uci' }
    let lastEngineExplainRaw = '';
    let fenHistory = []; // FEN history snapshots (initial position at index 0)
    // Tracing instrumentation (can be toggled via window.TRACE_MOVES)
    window.TRACE_MOVES = window.TRACE_MOVES !== undefined ? window.TRACE_MOVES : true;
    const TRACE_SQUARES = new Set(['e5','d5','d4','e4']);
    function traceLog(label, obj) {
      if (!window.TRACE_MOVES) return;
      try { console.log('[trace]', label, JSON.stringify(obj)); }
      catch { console.log('[trace]', label, obj); }
    }

    function updateBoardState(newFen) {
      boardStateFen = newFen;
      currentFen = newFen; // keep older code functional
      syncSideToMoveFromFen();
      renderBoard();
      engineEvaluateFen();
      const $fenCur = $('#fenCurrent');
      if ($fenCur.length) $fenCur.val(boardStateFen);
    }
    
    function isBoardRotated() {
      return !!boardFlipped;
    }

    function syncSideToMoveFromFen() {
      const parts = (boardStateFen || '').split(' ');
      if (parts.length > 1 && (parts[1] === 'w' || parts[1] === 'b')) {
        sideToMove = parts[1];
      }
    }

    function debugCall(name) {
      if (!debugLogging) return;
      console.log('[debug] call:', name);
    }

    function logLine(msg) {
      debugCall('logLine');
      const $log = $('#log');
      if (!$log.length) return;

      const ts = new Date().toISOString().substr(11, 8);
      $('<div>').text('[' + ts + '] ' + msg).appendTo($log);
      $log.scrollTop($log.prop('scrollHeight'));
    }

    function setEngineIO(text) {
      debugCall('setEngineIO');
      const $box = $('#engineIO');
      if (!$box.length) return;

      $box.val(text);
      $box.scrollTop($box.prop('scrollHeight'));
    }

    function updatePgnBox() {
      debugCall('updatePgnBox');
      const $box = $('#pgn');
      if (!$box.length) return;

      let res = '';
      for (let i = 0; i < gameMoves.length; i += 2) {
        const moveNumber = 1 + (i / 2);
        const whiteMove = gameMoves[i] || '';
        const blackMove = gameMoves[i + 1] || '';

        res += moveNumber + '. ' + whiteMove;
        if (blackMove) {
          res += ' ' + blackMove;
        }
        if (i + 2 < gameMoves.length) {
          res += ' ';
        }
      }

      // Append PGN result token if the position is terminal
      try {
        if (window.EngineBridge && typeof window.EngineBridge.detectTerminal === 'function') {
          const term = JSON.parse(window.EngineBridge.detectTerminal(boardStateFen) || '{}');
          let resultToken = '';
          if (term && term.status) {
            if (term.status === 'checkmate') {
              resultToken = term.winner === 'w' ? '1-0' : '0-1';
            } else if (term.status === 'stalemate' || term.status === 'draw-insufficient') {
              resultToken = '1/2-1/2';
            }
          }
          if (resultToken) {
            res = res.trim();
            res = res ? (res + ' ' + resultToken) : resultToken;
          }
        }
      } catch { /* ignore PGN result errors */ }

      $box.val(res.trim());
    }

    function parseBoardArray(fen) {
      debugCall('parseBoardArray');
      const boardPart = (fen || '').split(' ')[0] || '';
      const rows = boardPart.split('/');
      const grid = Array.from({ length: 8 }, () => Array(8).fill('.'));

      for (let r = 0; r < 8 && r < rows.length; r++) {
        let c = 0;
        for (const ch of rows[r]) {
          if (/^[1-8]$/.test(ch)) {
            c += parseInt(ch, 10);
          } else {
            if (c < 8) grid[r][c++] = ch;
          }
        }
      }

      return grid;
    }

    function flipFenString(fen) {
      debugCall('flipFenString');
      try {
        const parts = (fen || '').trim().split(/\s+/);
        if (parts.length < 6) return fen;

        const placement = parts[0];
        const side = parts[1];
        const cast = parts[2];
        const ep = parts[3];
        const half = parts[4];
        const full = parts[5];

        const ranks = placement.split('/');
        if (ranks.length !== 8) return fen;

        const squares = new Array(64).fill('.');
        for (let r = 0; r < 8; r++) {
          let file = 0;
          for (const ch of ranks[r]) {
            if (/^[1-8]$/.test(ch)) {
              const n = parseInt(ch, 10);
              for (let k = 0; k < n; k++) {
                squares[r * 8 + file] = '.';
                file++;
              }
            } else {
              squares[r * 8 + file] = ch;
              file++;
            }
          }
          if (file !== 8) return fen;
        }

        const out = new Array(64).fill('.');
        for (let i = 0; i < 64; i++) {
          let p = squares[i];
          const j = 63 - i;
          if (p !== '.') {
            const upper = p.toUpperCase();
            const lower = p.toLowerCase();
            p = (p === upper) ? lower : upper;
          }
          out[j] = p;
        }

        const rowsOut = [];
        for (let r = 0; r < 8; r++) {
          let row = '';
          let empty = 0;
          for (let c = 0; c < 8; c++) {
            const p = out[r * 8 + c];
            if (p === '.') {
              empty++;
            } else {
              if (empty) {
                row += String(empty);
                empty = 0;
              }
              row += p;
            }
          }
          if (empty) row += String(empty);
          rowsOut.push(row);
        }

        const newPlacement = rowsOut.join('/');
        const newSide = (side === 'w') ? 'b' : 'w';

        // Castling rights transform for KQkq and X-FEN letters A-H/a-h with file mirroring
        let outCastArr = [];
        const addCast = (ch) => { if (!ch) return; outCastArr.push(ch); };
        for (const ch of (cast || '')) {
          if (ch === 'K') addCast('k');
          else if (ch === 'Q') addCast('q');
          else if (ch === 'k') addCast('K');
          else if (ch === 'q') addCast('Q');
          else if (ch >= 'A' && ch <= 'H') {
            const rf = ch.charCodeAt(0) - 65; // 0..7
            const mr = 7 - rf;
            addCast(String.fromCharCode(97 + mr)); // to lowercase mirrored file
          } else if (ch >= 'a' && ch <= 'h') {
            const rf = ch.charCodeAt(0) - 97;
            const mr = 7 - rf;
            addCast(String.fromCharCode(65 + mr)); // to uppercase mirrored file
          }
        }
        // de-duplicate while preserving order
        const seen = new Set();
        const outCast = outCastArr.filter(ch => (seen.has(ch) ? false : (seen.add(ch), true))).join('') || '-';

        let epOut = '-';
        if (ep && ep.length === 2 && /^[a-h][1-8]$/.test(ep)) {
          const f = ep.charCodeAt(0) - 97;
          const r = ep.charCodeAt(1) - 49;
          const nf = 7 - f;
          const nr = 7 - r;
          epOut = String.fromCharCode(97 + nf) + String.fromCharCode(49 + nr);
        }

        return `${newPlacement} ${newSide} ${outCast} ${epOut} ${half} ${full}`;
      } catch {
        return fen;
      }
    }

    function flipSquare180(alg) {
      debugCall('flipSquare180');
      if (!alg || alg.length !== 2) return alg;
      const f = alg.charCodeAt(0) - 97;
      const r = alg.charCodeAt(1) - 49;
      if (f < 0 || f > 7 || r < 0 || r > 7) return alg;
      const nf = 7 - f;
      const nr = 7 - r;
      return String.fromCharCode(97 + nf) + String.fromCharCode(49 + nr);
    }

    function flipMoveUci180(uci) {
      debugCall('flipMoveUci180');
      if (!uci || uci.length < 4) return uci;
      const from = uci.slice(0, 2);
      const to = uci.slice(2, 4);
      const promo = uci.length > 4 ? uci.slice(4) : '';
      return flipSquare180(from) + flipSquare180(to) + promo;
    }

    function renderBoard() {
      debugCall('renderBoard');

      const $board = $('#board');
      if (!$board.length) return;

      $board.empty();
      // Expose current rotation for tests and debugging only (no CSS rotation used)
      $board.attr('data-rotated', boardFlipped ? '180' : '0');

      const grid = parseBoardArray(currentFen);

      // Precompute legal move highlighting sets
      const humanColor = engineIsWhite ? 'b' : 'w';
      const hasLegals = Array.isArray(legalHumanMoves) && legalHumanMoves.length > 0 && sideToMove === humanColor;
      const originSet = new Set();
      const destSet = new Set();
      if (hasLegals) {
        { // debug: entry log and assertions
          try {
            console.log('[renderBoard][legals] enter {', {
              sideToMove,
              humanColor,
              selectedSquare,
              legalHumanMovesLen: legalHumanMoves ? legalHumanMoves.length : 0
            }, '}');
            console.assert(typeof sideToMove === 'string', '[ASSERT] sideToMove must be string');
            console.assert(humanColor === 'w' || humanColor === 'b', '[ASSERT] humanColor must be w/b', humanColor);
            if (selectedSquare !== null && selectedSquare !== undefined) {
              console.assert(typeof selectedSquare === 'string' && selectedSquare.length === 2, '[ASSERT] selectedSquare malformed', selectedSquare);
            }
            console.assert(Array.isArray(legalHumanMoves), '[ASSERT] legalHumanMoves must be an array');
            console.assert(legalHumanMoves.length > 0, '[ASSERT] legalHumanMoves must be non-empty');
          } catch {}
        }
        for (const u of legalHumanMoves) {
          { // inner-scope for breakpointing and pretty inspection
            try {
              console.assert(typeof u === 'string' && u.length >= 4, '[ASSERT] move UCI malformed', u);
            } catch {}
            const f = u.slice(0, 2);
            const t = u.slice(2, 4);
            { // debug: e5 watch
              // TODO: remove hack — temporary verbose logging for any occurrence of 'e5'
              try {
                if ((u && u.includes('e5')) || f === 'e5' || t === 'e5' || selectedSquare === 'e5') {
                  console.log('[renderBoard][e5-watch] {', {
                    u,
                    from: f,
                    to: t,
                    selectedSquare,
                    boardFlipped,
                    sideToMove,
                    humanColor
                  }, '}');
                }
              } catch {}
            }
            try { originSet.add(f); } catch {}
            if (selectedSquare) {
              { // nested if for precise breakpoints
                if (f === selectedSquare) {
                  { // deepest scope
                    try { destSet.add(t); } catch {}
                  }
                } else {
                  { // debug: non-matching origin to current selection
                    try { /* no-op debug branch */ } catch {}
                  }
                }
              }
            } else {
              { // debug: selectedSquare is null
                try { /* selectedSquare is not set; no dests added */ } catch {}
              }
            }
          }
        }
        { // debug: exit log
          try {
            const originFew = Array.from(originSet).slice(0, 12);
            const destFew = Array.from(destSet).slice(0, 12);
            console.log('[renderBoard][legals] exit {', {
              selectedSquare,
              originCount: originSet.size,
              destCount: destSet.size,
              originFew,
              destFew
            }, '}');
          } catch {}
        }
        // Add castling rook landing highlight squares in Standard when king selected
        try {
          const modeHL = ($('#variantSelect').val() || 'standard');
          if (modeHL === 'standard' && selectedSquare) {
            const sel = selectedSquare.toLowerCase();
            if (sel === 'e1' || sel === 'e8') {
              const ks = legalHumanMoves.includes(sel + 'g' + sel.slice(1)); // e1g1/e8g8
              const qs = legalHumanMoves.includes(sel + 'c' + sel.slice(1)); // e1c1/e8c8
              if (ks) destSet.add(sel === 'e1' ? 'f1' : 'f8');
              if (qs) destSet.add(sel === 'e1' ? 'd1' : 'd8');
            }
          }
        } catch {}
      }

      // Helper to get piece at an algebraic square from current FEN
      function getPieceAt(sq){
        const placement = (currentFen || '').split(' ')[0] || '';
        const rows = placement.split('/');
        if (rows.length!==8) return '.';
        const f=sq.charCodeAt(0)-97; const rank=sq.charCodeAt(1)-49; if(f<0||f>7||rank<0||rank>7) return '.';
        const rr=7-rank; let cc=0; for(const ch of rows[rr]){ if(/^[1-8]$/.test(ch)){ cc+=parseInt(ch,10);} else { if(cc===f) return ch; cc++; } }
        return '.';
      }

      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          const $div = $('<div class="square">');
          $div.addClass(((r + c) % 2) ? 'dark' : 'light');

          // Map visual square to algebraic without CSS transforms.
          // When flipped (black at bottom), both axes are inverted.
          const fileIdx = boardFlipped ? 7 - c : c;
          const rankIdx = boardFlipped ? r : 7 - r;
          const fileChar = String.fromCharCode(97 + fileIdx);
          const rankChar = String.fromCharCode(49 + rankIdx);
          const sq = fileChar + rankChar;
          $div.data('sq', sq);
          // Also persist as an HTML data-* attribute so non-jQuery callers (e.g., tests)
          // can reliably query by square without needing jQuery's internal data store.
          $div.attr('data-sq', sq);
          if (TRACE_SQUARES.has(sq)) traceLog('square.init', { sq, r, c, boardFlipped, selectedSquare });

          if (selectedSquare === sq) {
            $div.addClass('selected');
          }

          if (hasLegals) {
            if (originSet.has(sq)) $div.addClass('legal-origin');
            if (destSet.has(sq)) $div.addClass('legal-dest');
            if (TRACE_SQUARES.has(sq)) traceLog('square.legals-tag', { sq, origin: originSet.has(sq), dest: destSet.has(sq) });
          }

          // Add small coordinate label inside each square
          try {
            const $lab = $('<div class="sq-label">').text(sq);
            $div.append($lab);
          } catch {}

          // Determine and render the correct piece for this algebraic square
          const piece = getPieceAt(sq);
          if (piece && piece !== '.') {
            const isWhite = (piece === piece.toUpperCase());
            const $img = $('<img>', {
              src: PIECE_IMAGES[piece] || '',
              alt: piece
            }).css({
              width: '56px',
              height: '56px'
            }).prop('draggable', false);
            // Expose test-friendly attributes so headless tests can
            // easily introspect the board state.
            $div.attr('data-piece', piece);
            $div.attr('data-color', isWhite ? 'white' : 'black');
            $div.append($img);
            if (TRACE_SQUARES.has(sq)) traceLog('square.piece', { sq, piece, isWhite });
          } else {
            // Ensure empty squares do not carry stale metadata
            $div.removeAttr('data-piece');
            $div.removeAttr('data-color');
            if (TRACE_SQUARES.has(sq)) traceLog('square.empty', { sq });
          }

          $board.append($div);
        }
      }
    }

    function simpleSanFromUci(uci, fenBefore) {
      debugCall('simpleSanFromUci');
      if (!uci || uci.length < 4) return uci || '';
      try {
        const fen = fenBefore || boardStateFen;
        const placement = (fen || '').split(' ')[0] || '';
        const rows = placement.split('/');
        if (rows.length !== 8) return uci;
        const board = Array.from({ length: 8 }, () => Array(8).fill('.'));
        for (let r = 0; r < 8; r++) {
          let c = 0;
          for (const ch of rows[r]) {
            if (/^[1-8]$/.test(ch)) c += parseInt(ch, 10);
            else if (c < 8) board[r][c++] = ch;
          }
        }
        const from = uci.slice(0, 2);
        const file = from.charCodeAt(0) - 97;
        const rank = from.charCodeAt(1) - 49;
        if (file < 0 || file > 7 || rank < 0 || rank > 7) return uci;
        const rr = 7 - rank;
        const cc = file;
        const piece = board[rr][cc];
        if (!piece || piece === '.' || piece.toLowerCase() === 'p') return uci;
        return piece.toUpperCase() + uci;
      } catch {
        return uci;
      }
    }

    function updateScore(cp) {
      debugCall('updateScore');

      const $score = $('#score');
      if (!$score.length) return;

      if (cp === null || cp === undefined) {
        $score.text('--');
        return;
      }

      const pawns = (cp / 100).toFixed(2);
      $score.text((cp >= 0 ? '+' : '') + pawns);
    }

    function engineEvaluateFen() {
      debugCall('engineEvaluateFen');
      if (!window.EngineBridge) return;
      let cp = null;
      if (window.EngineBridge.evaluateFEN) {
        cp = window.EngineBridge.evaluateFEN(boardStateFen);
      }
      updateScore(cp);

      // Also keep Engine I/O box roughly in sync after arbitrary FEN changes
      let ioText = '';
      ioText += 'fen (original board): ' + boardStateFen + '\n';
      ioText += '\n[explain.math]\n';
      ioText += 'Stub evaluation: material-only score ' + (cp !== null ? cp + ' cp' : 'n/a') + '.\n';
      setEngineIO(ioText);
    }

    function engineChooseBestMove() {
      debugCall('engineChooseBestMove');
      if (!window.EngineBridge || !window.EngineBridge.chooseBestMove) {
        logLine('Engine chooseBestMove not available');
        return;
      }

      const depth = parseInt($('#depth').val(), 10) || 2;
      const optsJson = JSON.stringify({ searchDepth: depth });
      const stm = boardStateFen.split(' ')[1];
      // Turn validation depending on engine color
      if (engineIsWhite && stm !== 'w') {
        logLine('ERROR: Engine Move pressed but it is not white to move.');
        return;
      }
      if (!engineIsWhite && stm !== 'b') {
        logLine('ERROR: Engine Move pressed but it is not black to move.');
        return;
      }
      const flipComm = !engineIsWhite; // flip inbound/outbound when engine plays black
      const fenForEngine = flipComm ? flipFenString(boardStateFen) : boardStateFen;

      logLine('ENGINE (white) MOVE REQUEST: chooseBestMove');
      logLine('  fen (board->engine): ' + fenForEngine);
      logLine('  options: ' + optsJson);

      const t0 = performance.now();
      const res = window.EngineBridge.chooseBestMove(fenForEngine, optsJson);
      const t1 = performance.now();

      if (!res) {
        logLine('ENGINE ERROR: null response from chooseBestMove');
        return;
      }

      logLine('ENGINE RESPONSE RAW: ' + res);

      let obj = null;
      try {
        obj = JSON.parse(res);
      } catch (e) {
        logLine('ENGINE PARSE ERROR: ' + e);
        return;
      }

      let engineUci = obj && obj.best && obj.best.uci ? obj.best.uci : null;
      if (!engineUci) {
        logLine('ENGINE RESULT: missing best.uci');
        return;
      }
      // If communication flipped (engine playing black), flip move back to board space
      const boardUci = flipComm ? flipMoveUci180(engineUci) : engineUci;

      let ioText = '';
      ioText += 'fen (original board): ' + boardStateFen + '\n';
      ioText += 'fen sent to engine : ' + fenForEngine + '\n';
      ioText += 'engine best uci    : ' + engineUci + '\n';
      ioText += 'board-applied uci  : ' + boardUci + '\n';
      if (obj.status) {
        ioText += 'status             : ' + obj.status + '\n';
      }
      if (obj.explain && obj.explain.math) {
        ioText += '\n[explain.math]\n' + obj.explain.math + '\n';
      }
      setEngineIO(ioText);

      // Store and display explanation summary + raw JSON
      lastEngineExplainRaw = res;
      updateExplanationBoxes(obj, res);

      const nodesInfo = (typeof obj.nodesTotal === 'number') ? ', nodes=' + obj.nodesTotal : '';
      const depthInfo = (typeof obj.depth === 'number') ? ', depth=' + obj.depth : '';
      const scoreInfo = (obj.best && typeof obj.best.score === 'number') ? ', score=' + obj.best.score + ' cp' : '';
      logLine('ENGINE (white) RESULT: best=' + engineUci + ' (board=' + boardUci + ')' + scoreInfo + depthInfo + nodesInfo + ' in ' + (t1 - t0).toFixed(1) + ' ms');

      // Compute move token using pre-move FEN so piece detection is correct
      const san = simpleSanFromUci(boardUci, boardStateFen);
      const nextFen = fenApplyUciMove(boardStateFen, boardUci);
      if (!applyMoveAndRecord(nextFen, san)) {
        logLine('ENGINE MOVE APPLY FAILED for uci=' + boardUci);
        return;
      }

      // After engine moves, compute legal human moves (2-ply prune)
      requestHumanLegalMoves2Ply();
    }

    function tryHumanMove(fromSq, toSq, evtOrOpts) {
      debugCall('tryHumanMove');
      if (!fromSq || !toSq || fromSq === toSq) return;
      traceLog('move.start', { from: fromSq, to: toSq, sideToMove, boardFlipped });
      syncSideToMoveFromFen();
      const humanColor = engineIsWhite ? 'b' : 'w';
      if (sideToMove !== humanColor) {
        logLine('Human move ignored: not ' + (humanColor === 'w' ? 'white' : 'black') + " to move.");
        traceLog('move.reject.turn', { from: fromSq, to: toSq, sideToMove, humanColor });
        return;
      }
      // Require known legals and enforce membership
      if (!Array.isArray(legalHumanMoves) || legalHumanMoves.length === 0) {
        logLine('Awaiting legal moves; please wait.');
        traceLog('move.reject.no-legals', { from: fromSq, to: toSq });
        return;
      }
      let uciPresentation = fromSq + toSq; // based on provided squares
      // Always prefer the direct UCI constructed from the provided squares.
      // If that doesn't match the legal set (e.g., caller passed presentation-space coords),
      // fall back to the 180°-flipped version.
      const uciFlipped = flipMoveUci180(uciPresentation);
      const prefer = [uciPresentation, uciFlipped];
      let uci = prefer[0];
      traceLog('move.candidates', { prefer, chosenInitial: uci, legalsLen: legalHumanMoves.length });
      try { if (debugLogging) console.log('[ui] tryHumanMove candidates', { prefer, legalsLen: legalHumanMoves.length }); } catch {}
      // Diagnostic: show move candidates and current legal set head
      try {
        const head = (legalHumanMoves || []).slice(0, 12).join(' ');
        logLine('HUMAN candidate(s): ' + prefer.join(' | ') + ' | legals[0..11]: ' + head);
        if (debugLogging) console.log('[ui] legals head', head);
      } catch {}
      // Promotion handling: if pawn reaches last rank, append promotion piece (default 'q').
      try {
        const ctrlHeld = !!(evtOrOpts && (evtOrOpts.ctrlKey || evtOrOpts.ctrl));
        const forcedPromo = (evtOrOpts && typeof evtOrOpts.promotion === 'string') ? (evtOrOpts.promotion || '').toLowerCase() : null;
        const placement = (boardStateFen || '').split(' ')[0] || '';
        function getPieceAt(sq){
          const rows = placement.split('/');
          if (rows.length!==8) return '.';
          const f=sq.charCodeAt(0)-97; const r=sq.charCodeAt(1)-49; if(f<0||f>7||r<0||r>7) return '.';
          const rr=7-r; let cc=0; for(const ch of rows[rr]){ if(/^[1-8]$/.test(ch)){ cc+=parseInt(ch,10);} else { if(cc===f) return ch; cc++; } }
          return '.';
        }
        const from = uci.slice(0,2), to = uci.slice(2,4);
        const mover = getPieceAt(from);
        const isPawn = mover && mover.toLowerCase()==='p';
        const toRankNum = (to.charCodeAt(1)-49)+1; // 1..8
        const isWhitePawn = mover === mover.toUpperCase();
        const reachesLast = isPawn && ((isWhitePawn && toRankNum===8) || (!isWhitePawn && toRankNum===1));
        if (reachesLast) {
          let promo = (forcedPromo && /^[qrbn]$/.test(forcedPromo)) ? forcedPromo : 'q';
          if (!forcedPromo && ctrlHeld) {
            const choice = (prompt('Promote to (q,r,b,n)?','q') || 'q').trim().toLowerCase();
            if (/^[qrbn]$/.test(choice)) promo = choice;
          }
          uci += promo;
        }
      } catch {}
      logLine('HUMAN (' + (humanColor === 'w' ? 'white' : 'black') + ') MOVE REQUEST: ' + uciPresentation + ' (board-candidate=' + uci + ')');
      try { if (debugLogging) console.log('[ui] includes direct?', legalHumanMoves.includes(uciPresentation), 'includes flipped?', legalHumanMoves.includes(uciFlipped)); } catch {}
      if (!legalHumanMoves.includes(uci)) {
        // Try alternate candidate if first choice not legal
        const alt = prefer[1];
        logLine('HUMAN move not in legals, trying alt: ' + alt);
        traceLog('move.alt.try', { original: uci, alt });
        if (legalHumanMoves.includes(alt)) {
          uci = alt;
          traceLog('move.alt.accept', { accepted: uci });
        }
      }
      // Handle flipped-engine castling alias in Standard mode: only kingside needs alias mapping
      if (!legalHumanMoves.includes(uci)) {
        try {
          const from = uciPresentation.slice(0,2).toLowerCase();
          const to = uciPresentation.slice(2,4).toLowerCase();
          const isStdRank = (from === 'e1' || from === 'e8');
          const isKingside = (to === 'g1' || to === 'g8');
          if (isStdRank && isKingside) {
            const alias = (from === 'e1' ? 'e1b1' : 'e8b8');
            if (legalHumanMoves.includes(alias)) {
              logLine('HUMAN castling alias matched; accepting ' + uciPresentation + ' via alias ' + alias);
              // Keep applying the original board move so rook relocation logic triggers correctly
              uci = uciPresentation;
            }
          }
        } catch {}
      }
      if (!legalHumanMoves.includes(uci)) {
        // Extra diagnostics to understand mismatches
        try {
          const sample = (legalHumanMoves || []).slice(0, 20).join(' ');
          logLine('ILLEGAL move rejected: ' + uci + ' (not in legal set). Sample legals: ' + sample);
          traceLog('move.illegal', { uci, sampleLen: legalHumanMoves.length });
        } catch {
          logLine('ILLEGAL move rejected: ' + uci + ' (not in legal set)');
          traceLog('move.illegal.simple', { uci });
        }

        // HACK fallback: Re-query engine legals directly and, if intended move is legal,
        // force-apply the result by updating the FEN input and advancing the board state
        // so the game can continue. Users will only notice the FEN text changing.
        try {
          if (window.EngineBridge && window.EngineBridge.listLegalMoves2Ply) {
            const humanColor = engineIsWhite ? 'b' : 'w';
            const flipComm = engineIsWhite; // human presented as white to engine when engine is white
            const fenForEngine = flipComm ? flipFenString(boardStateFen) : boardStateFen;
            const res = window.EngineBridge.listLegalMoves2Ply(fenForEngine, JSON.stringify({ ply: 2 }));
            let obj = null; try { obj = JSON.parse(res); } catch {}
            const rawMoves = (obj && Array.isArray(obj.moves)) ? obj.moves : [];
            const boardMoves = flipComm ? rawMoves.map(flipMoveUci180) : rawMoves.slice();
            // Prefer board-space intended move first
            const intended = prefer[0];
            const alt2 = prefer[1];
            let alias2 = null;
            try {
              const from0 = intended.slice(0,2).toLowerCase();
              const to0 = intended.slice(2,4).toLowerCase();
              const isStdRank0 = (from0 === 'e1' || from0 === 'e8');
              const isKing0 = (to0 === 'g1' || to0 === 'g8');
              if (isStdRank0 && isKing0) {
                alias2 = (from0 === 'e1' ? 'e1b1' : 'e8b8');
              }
            } catch {}
            const chosen = boardMoves.includes(intended) ? intended
                         : (boardMoves.includes(alt2) ? alt2
                         : (alias2 && boardMoves.includes(alias2) ? intended : null));
            if (chosen) {
              const san = simpleSanFromUci(chosen, boardStateFen);
              const nextFen = fenApplyUciMove(boardStateFen, chosen);
              if (nextFen) {
                // Reflect change in FEN input so it's visible to users, then advance board
                const $fenInput = $('#fenInput'); if ($fenInput.length) $fenInput.val(nextFen);
                updateBoardState(nextFen);
                selectedSquare = null;
                gameMoves.push(san);
                updatePgnBox();
                logLine('FALLBACK: Forced apply of legal move ' + chosen + ' after UI mismatch.');
                traceLog('move.fallback', { chosen, nextFen });
                // Precompute next legals for the human if still their turn
                requestHumanLegalMoves2Ply();
                return;
              }
            }
          }
        } catch {}
        renderBoard();
        return;
      }
      // Compute move token using pre-move FEN so piece detection is correct
      const san = simpleSanFromUci(uci, boardStateFen);
      const nextFen = fenApplyUciMove(boardStateFen, uci);
      if (!nextFen) {
        logLine('HUMAN MOVE APPLY FAILED for uci=' + uci);
        traceLog('move.apply.failed', { uci });
        return;
      }
      applyMoveAndRecord(nextFen, san);
      selectedSquare = null;
      // Clear legals until engine replies and we recompute
      legalHumanMoves = null;
      try { logLine('HUMAN move applied: ' + uci + ' | FEN: ' + nextFen); } catch {}
      try { if (debugLogging) console.log('[ui] human move applied', { uci, fen: nextFen }); } catch {}
      traceLog('move.apply.success', { uci, san, nextFen });
    }

    function newGame() {
      debugCall('newGame');

      const mode = ($('#variantSelect').val() || 'standard');
      let fenText = ($('#fenInput').val() || '').toString().trim();
      if (!fenText) {
        fenText = (mode === 'chess960') ? generateChess960Start() : START_FEN;
        const $fenIn = $('#fenInput'); if ($fenIn.length) $fenIn.val(fenText);
      }
      boardFlipped = engineIsWhite; // bottom side is human color
      humanIsBlack = engineIsWhite; // if engine plays black, human is white
      gameMoves = [];
      fenHistory = [];
      $('#humanSideLabel').text(engineIsWhite ? 'black (presentation)' : 'white (presentation)');

      selectedSquare = null;
      updateBoardState(fenText);
      updatePgnBox();
      setEngineIO('');
      fenHistory.push(boardStateFen);

      // If human starts, precompute legal moves
      syncSideToMoveFromFen();
      const humanColor = engineIsWhite ? 'b' : 'w';
      if (sideToMove === humanColor) {
        requestHumanLegalMoves2Ply();
      }

      const $imgs = $('#board img');
      if ($imgs.length === 0) {
        console.error('New Game: renderBoard completed but no piece images were found under #board.');
        console.error('Check that PIECE_IMAGES paths are correct and that currentFen has pieces in the placement field.');
      }

      logLine('New game started. Engine plays ' + (engineIsWhite ? 'white' : 'black') + '; human plays ' + (engineIsWhite ? 'black' : 'white') + ' at bottom.');
    }

    function flipBoardOnly() {
      debugCall('flipBoardOnly');
      boardFlipped = !boardFlipped;
      renderBoard();
      logLine('Board visual flipped 180 degrees.');
    }

    function applyMoveAndRecord(nextFen, sanToken) {
      if (!nextFen) return false;
      updateBoardState(nextFen);
      fenHistory.push(nextFen);
      if (sanToken) gameMoves.push(sanToken);
      updatePgnBox();
      return true;
    }

    function undoLast() {
      debugCall('undoLast');
      if (fenHistory.length <= 1) { logLine('Undo: nothing to revert.'); return; }
      const humanColor = engineIsWhite ? 'b' : 'w';
      if (sideToMove === humanColor) {
        // engine just moved; undo two halfmoves if possible
        if (fenHistory.length >= 3) {
          fenHistory.splice(-2);
          gameMoves.splice(-2);
        } else {
          fenHistory.splice(-1);
          gameMoves.splice(-1);
        }
      } else {
        // human just moved; undo one
        fenHistory.splice(-1);
        gameMoves.splice(-1);
      }
      const restored = fenHistory[fenHistory.length - 1];
      boardStateFen = restored;
      currentFen = restored;
      syncSideToMoveFromFen();
      renderBoard();
      engineEvaluateFen();
      updatePgnBox();
      logLine('Undo completed. Side to move: ' + sideToMove);
      const humanColorNow = engineIsWhite ? 'b' : 'w';
      if (sideToMove === humanColorNow) requestHumanLegalMoves2Ply();
    }

    function init() {
      debugCall('init');

      if (window.EngineBridge && window.EngineBridge.setRandomSeed) {
        try {
          window.EngineBridge.setRandomSeed(12345);
          logLine('Engine RNG seed set to 12345');
        } catch {
        }
      }

      $('#btnNewGame').on('click', function () {
        debugCall('btnNewGame.click');
        newGame();
      });
      $('#btnFlip').on('click', function () {
        debugCall('btnFlip.click');
        flipBoardOnly();
      });
      $('#btnEngineMove').on('click', function () {
        debugCall('btnEngineMove.click');
        engineChooseBestMove();
      });
      // Inject Undo button after Engine Move
      $('<button id="btnUndo">Undo</button>').insertAfter('#btnEngineMove').on('click', function(){
        debugCall('btnUndo.click');
        undoLast();
      });

      // Variant selection and randomize 960
      function syncRandomizeButton() {
        const is960 = ($('#variantSelect').val() || 'standard') === 'chess960';
        const $btn = $('#btnRandom960'); if ($btn.length) $btn.prop('disabled', !is960);
      }
      $('#variantSelect').on('change', function(){
        syncRandomizeButton();
      });
      $('#btnRandom960').on('click', function(){
        const fen960 = generateChess960Start();
        const $fenIn = $('#fenInput'); if ($fenIn.length) $fenIn.val(fen960);
        logLine('Generated Chess960 start (X-FEN): ' + fen960);
      });
      // Load a Standard-mode castling test FEN with all rights enabled
      $('#btnStdCastle').on('click', function(){
        try {
          $('#variantSelect').val('standard');
          const humanColor = engineIsWhite ? 'b' : 'w';
          const side = humanColor; // ensure it's the human's turn
          // Use X-FEN castling rights for Standard: A/H for white rooks, a/h for black rooks
          const fenStdCastle = `r3k2r/8/8/8/8/8/8/R3K2R ${side} AHah - 0 1`;
          const $fenIn = $('#fenInput'); if ($fenIn.length) $fenIn.val(fenStdCastle);
          logLine('Loaded Standard castling test FEN: ' + fenStdCastle);
          newGame();
          // Proactively compute legals for human so castle squares highlight
          requestHumanLegalMoves2Ply();
        } catch(e){ logLine('Std Castle Test setup failed: ' + e); }
      });

      // Fallback typed human move handler
      $('#btnHumanMoveApply').on('click', function(){
        try {
          const raw = ($('#humanMoveInput').val() || '').toString().trim();
          const token = raw.replace(/\s+/g,'').toLowerCase();
          if (!token) { logLine('Enter a move like d5d4 or e7e8q, then press Apply.'); return; }
          if (!/^[a-h][1-8][a-h][1-8]([qrbn])?$/.test(token)) {
            logLine('Invalid move format. Use d5d4 or e7e8q for promotion.');
            return;
          }
          // Ensure legals are known
          if (!Array.isArray(legalHumanMoves) || legalHumanMoves.length === 0) {
            requestHumanLegalMoves2Ply();
          }
          const fromSq = token.slice(0,2);
          const toSq = token.slice(2,4);
          const promo = token.length>4 ? token.slice(4) : '';
          logLine('Applying typed human move: ' + token);
          traceLog('typed.move', { token, fromSq, toSq, promo });
          // Pass promotion override so no prompt and exact piece is used
          tryHumanMove(fromSq, toSq, { promotion: promo });
        } catch (e) {
          logLine('Typed move failed: ' + e);
        }
      });

      // Click-to-move handler for human moves
      $('#board').on('click', '.square', function (evt) {
        debugCall('board.square.click');
        const sq = $(this).data('sq');
        if (!sq) return;
        traceLog('click.start', { sq, selectedSquare, sideToMove, boardFlipped });
        try { traceLog('click.dom', { sq, piece: this.getAttribute('data-piece'), color: this.getAttribute('data-color'), classes: Array.from(this.classList) }); } catch {}

        // Do not allow destination selection until legals are known
        const humanColor = engineIsWhite ? 'b' : 'w';
        if (sideToMove === humanColor) {
          if (!Array.isArray(legalHumanMoves) || legalHumanMoves.length === 0) {
            // if missing, request them now
            requestHumanLegalMoves2Ply();
            logLine('Awaiting legal moves; click again once highlighted.');
            return;
          }
        }

        // Determine if clicked square contains a human piece
        const clickedColor = ($(this).attr('data-color') || '').toLowerCase();
        const humanColorWord = humanIsBlack ? 'black' : 'white';
        const isHumanPiece = clickedColor === humanColorWord;

        if (!selectedSquare) {
          // Only start selection on a human piece
          if (isHumanPiece) {
            selectedSquare = sq;
            // Sync Workaround textbox with the selected origin square
            try {
              const $in = $('#humanMoveInput');
              if ($in.length) $in.val(sq);
            } catch {}
            renderBoard();
            traceLog('selection.begin', { sq });
          }
          return;
        }

        // If clicking the same square, clear selection
        if (sq === selectedSquare) {
          selectedSquare = null;
          renderBoard();
          traceLog('selection.cancel', { sq });
          return;
        }

        // If clicking another human piece while a selection is active, switch selection
        if (isHumanPiece) {
          // Chess960 castling gesture: king then rook click triggers castling
          try {
            const mode = ($('#variantSelect').val() || 'standard');
            if (mode === 'chess960' && selectedSquare) {
              function getPieceAtFen(sq){ const placement=(boardStateFen||'').split(' ')[0]||''; const rows=placement.split('/'); if(rows.length!==8) return '.'; const f=sq.charCodeAt(0)-97; const r=sq.charCodeAt(1)-49; if(f<0||f>7||r<0||r>7) return '.'; const rr=7-r; let cc=0; for(const ch of rows[rr]){ if(/^[1-8]$/.test(ch)){ cc+=parseInt(ch,10);} else { if(cc===f) return ch; cc++; } } return '.'; }
              const pieceSel = getPieceAtFen(selectedSquare);
              const pieceClicked = getPieceAtFen(sq);
              if (pieceSel && pieceClicked && pieceSel.toLowerCase()==='k' && pieceClicked.toLowerCase()==='r') {
                const sameColor = (pieceSel===pieceSel.toUpperCase()) === (pieceClicked===pieceClicked.toUpperCase());
                if (sameColor) {
                  const entry = chess960CastleMoves[selectedSquare];
                  if (entry) {
                    const kFile = selectedSquare.charCodeAt(0);
                    const rFile = sq.charCodeAt(0);
                    const moveUci = (rFile > kFile) ? entry.kingside : entry.queenside;
                    if (moveUci) {
                      logLine('Chess960 castling gesture: ' + selectedSquare + ' then ' + sq + ' -> ' + moveUci);
                      const san = simpleSanFromUci(moveUci, boardStateFen);
                      const nextFen = fenApplyUciMove(boardStateFen, moveUci);
                      if (nextFen) {
                        updateBoardState(nextFen);
                        gameMoves.push(san);
                        updatePgnBox();
                        selectedSquare = null;
                        requestHumanLegalMoves2Ply();
                        traceLog('chess960.castle.applied', { moveUci, nextFen });
                        return; // consumed
                      } else {
                        logLine('Chess960 castling apply failed for move ' + moveUci);
                      }
                    }
                  }
                }
              }
            }
          } catch {}
          selectedSquare = sq;
          // Reset Workaround textbox to new origin square
          try {
            const $in = $('#humanMoveInput');
            if ($in.length) $in.val(sq);
          } catch {}
          renderBoard();
          traceLog('selection.switch', { sq });
          return;
        }

        // Otherwise, attempt move from selected to clicked square
        const fromSq = selectedSquare;
        const toSq = sq;
        selectedSquare = null;
        // Append destination to Workaround textbox (e.g., d5d4)
        try {
          const $in = $('#humanMoveInput');
          if ($in.length) $in.val(fromSq + toSq);
        } catch {}
        // Attempt the normal click-path move first
        const fenBefore = boardStateFen;
        tryHumanMove(fromSq, toSq, evt);
        // If no move occurred, programmatically trigger the Apply button as a fallback
        try {
          if (boardStateFen === fenBefore) {
            const $btn = $('#btnHumanMoveApply');
            if ($btn.length) {
              traceLog('fallback.apply-button', { token: (fromSq + toSq) });
              $btn.trigger('click');
            }
          }
        } catch {}
        traceLog('move.dispatch', { from: fromSq, to: toSq });
      });

      newGame();
      // MutationObserver for watched squares
      try {
        const boardEl = document.getElementById('board');
        if (boardEl && window.TRACE_MOVES) {
          const mo = new MutationObserver(muts => {
            for (const m of muts) {
              if (m.type === 'childList') {
                for (const sq of TRACE_SQUARES) {
                  const node = boardEl.querySelector('.square[data-sq="' + sq + '"]');
                  if (node) traceLog('mutation.childList', { sq, piece: node.getAttribute('data-piece'), color: node.getAttribute('data-color'), classes: Array.from(node.classList) });
                }
              } else if (m.type === 'attributes') {
                const sq = m.target.getAttribute('data-sq');
                if (sq && TRACE_SQUARES.has(sq)) traceLog('mutation.attr', { sq, attr: m.attributeName, value: m.target.getAttribute(m.attributeName) });
              }
            }
          });
          mo.observe(boardEl, { childList: true, subtree: true, attributes: true, attributeFilter: ['data-piece','class'] });
          traceLog('observer.ready', { squares: Array.from(TRACE_SQUARES) });
        }
      } catch {}
    }

    // Test/automation helper: perform a human move by ensuring legals are computed
    // and invoking the same pathway as click-to-move. Returns the updated FEN
    // string on success, or the original FEN if the move was rejected.
    function performHumanClickMove(fromSq, toSq, evtOrOpts) {
      try {
        debugCall('performHumanClickMove');
        try { console.log('[test-diag] performHumanClickMove invoked', { fromSq, toSq }); } catch {}
        try { logLine('performHumanClickMove: request from ' + fromSq + ' to ' + toSq); } catch {}
        // If legals aren't computed yet (e.g., new FEN just loaded), get them now.
        if (!Array.isArray(legalHumanMoves) || legalHumanMoves.length === 0) {
          requestHumanLegalMoves2Ply();
        }
        const fenBefore = boardStateFen;
        try {
          tryHumanMove(fromSq, toSq, evtOrOpts);
        } catch (err) {
          try { logLine('performHumanClickMove: tryHumanMove threw: ' + err); } catch {}
        }
        try { logLine('performHumanClickMove: fenBefore=' + fenBefore + ' | fenAfter=' + boardStateFen); } catch {}
        return boardStateFen;
      } catch (e){
        try { logLine('performHumanClickMove: unexpected error: ' + e); } catch {}
        return boardStateFen;
      }
    }

    $(function () {
      const params = new URLSearchParams(window.location.search);
      debugLogging = params.get('debug') === 'true';
      if (debugLogging) {
        console.log('[debug] query param debug=true detected; enabling call logging');
      }

      debugCall('document.ready');

      // Basic runtime checks that required assets and APIs are present.
      // Skip asset checks under JSDOM test environment.
      if (!window.JSDOM_TEST_ENV) {
        const missing = [];
        $.ajax({
          url: 'engine-bridge2.js',
          method: 'HEAD'
        }).fail(function () {
          missing.push('engine-bridge2.js (bridge JS file not found)');
          console.error('Asset check: engine-bridge2.js is not reachable from this page.');
        }).always(function () {
          const hasEngineBridge = !!window.EngineBridge;
          if (!hasEngineBridge) {
            missing.push('window.EngineBridge (bridge object not defined)');
            console.error('Asset check: window.EngineBridge is not defined.');
          }

          const hasWasmModule = hasEngineBridge && !!window.EngineBridge.wasmModule;
          if (!hasWasmModule) {
            console.warn('Asset check: EngineBridge.wasmModule is missing; WASM may not be loaded yet.');
          }

          if (missing.length) {
            logLine('ASSET CHECK FAILED: ' + missing.join('; '));
          } else {
            logLine('ASSET CHECK OK: engine bridge JS reachable; EngineBridge object present.');
          }
        });
      }

      if (window.EngineBridge && window.EngineBridge.wasmReady) {
        init();
      } else {
        $(window).one('engine-bridge-ready', function () {
          debugCall('engine-bridge-ready');
          init();
        });
      }
      // Initialize variant UI state
      (function(){ try { const v = localStorage.getItem('variantSelect'); if (v) $('#variantSelect').val(v); } catch{}; })();
      try { if (typeof syncRandomizeButton === 'function') { syncRandomizeButton(); } } catch {}
      $('#variantSelect').on('change', function(){ try { localStorage.setItem('variantSelect', $('#variantSelect').val()); } catch{} });
    });

    // Expose selected helpers for tests/automation
    window.performHumanClickMove = performHumanClickMove;

    function updateExplanationBoxes(obj, raw) {
      debugCall('updateExplanationBoxes');
      const $sum = $('#explainSummary');
      const $raw = $('#explainRaw');
      if (!$sum.length || !$raw.length) return;
      let summary = 'n/a';
      if (obj && obj.explain && typeof obj.explain.math === 'string') {
        summary = obj.explain.math.trim();
      }
      if (obj && obj.status && obj.status !== 'ok') {
        summary = ('status=' + obj.status + ' | ') + summary;
      }
      $sum.text(summary);
      $raw.val(raw);
    }

    $(document).on('click', '#btnCopyExplain', function () {
      debugCall('btnCopyExplain.click');
      const raw = $('#explainRaw').val() || '';
      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(raw).then(() => {
          logLine('Explanation JSON copied to clipboard.');
        }).catch(() => {
          fallbackCopy(raw);
        });
      } else {
        fallbackCopy(raw);
      }
      function fallbackCopy(text) {
        const ta = document.createElement('textarea');
        ta.value = text;
        ta.style.position = 'fixed';
        ta.style.top = '-1000px';
        document.body.appendChild(ta);
        ta.select();
        try { document.execCommand('copy'); logLine('Explanation JSON copied (fallback).'); } catch (e) { logLine('Copy failed: ' + e); }
        document.body.removeChild(ta);
      }
    });

    function requestHumanLegalMoves2Ply() {
      debugCall('requestHumanLegalMoves2Ply');
      if (!window.EngineBridge || !window.EngineBridge.listLegalMoves2Ply) return;
      syncSideToMoveFromFen();
      const humanColor = engineIsWhite ? 'b' : 'w';
      if (sideToMove !== humanColor) return; // Only compute when it's human turn
      const flipComm = engineIsWhite; // when engine depicted white, flip to make human side appear white to engine
      const fenForEngine = flipComm ? flipFenString(boardStateFen) : boardStateFen;
      const t0 = performance.now();
      const res = window.EngineBridge.listLegalMoves2Ply(fenForEngine, JSON.stringify({ ply: 2 }));
      const t1 = performance.now();
      let obj = null;
      try { obj = JSON.parse(res); } catch { obj = null; }
      if (!obj || !Array.isArray(obj.moves)) {
        logLine('LEGAL MOVES ERROR: could not parse engine response');
        return;
      }
      // Flip moves back to board space if needed
      const rawMoves = obj.moves || [];
      let movesBoard = flipComm ? rawMoves.map(flipMoveUci180) : rawMoves.slice();
      // Castling post-processing: Standard canonicalization; Chess960 gesture extraction
      try {
        const mode = ($('#variantSelect').val() || 'standard');
        chess960CastleMoves = {}; // reset each computation
        if (mode === 'standard' && Array.isArray(movesBoard)) {
          const mapped = [];
          for (const m of movesBoard) {
            if (typeof m !== 'string' || m.length < 4) { mapped.push(m); continue; }
            const from = m.slice(0,2).toLowerCase();
            const to = m.slice(2,4).toLowerCase();
            if (from === 'e1') {
              if (to === 'b1') { mapped.push('e1g1'); continue; }
              if (to === 'f1') { mapped.push('e1c1'); continue; }
            } else if (from === 'e8') {
              if (to === 'b8') { mapped.push('e8g8'); continue; }
              if (to === 'f8') { mapped.push('e8c8'); continue; }
            }
            mapped.push(m);
          }
          const seen = new Set();
          movesBoard = mapped.filter(x => (seen.has(x) ? false : (seen.add(x), true)));
        } else if (mode === 'chess960' && Array.isArray(movesBoard)) {
          const retained = [];
          for (const m of movesBoard) {
            if (typeof m === 'string' && m.length >= 4) {
              const from = m.slice(0,2);
              const to = m.slice(2,4);
              if (/^[a-h][1-8]$/.test(from) && /^[a-h][1-8]$/.test(to)) {
                const toFile = to.charAt(0);
                if (toFile === 'c' || toFile === 'g') {
                  const entry = chess960CastleMoves[from] || { kingside: null, queenside: null };
                  if (toFile === 'g') entry.kingside = m;
                  if (toFile === 'c') entry.queenside = m;
                  chess960CastleMoves[from] = entry;
                  continue; // remove from legals, must use king+rook gesture
                }
              }
            }
            retained.push(m);
          }
          movesBoard = retained;
          try { logLine('Chess960 castle gesture moves captured: ' + JSON.stringify(chess960CastleMoves)); } catch {}
        }
      } catch {}
      legalHumanMoves = movesBoard;
      logLine('Legal moves ready: ' + legalHumanMoves.length + ' moves (computed in ' + (t1 - t0).toFixed(1) + ' ms)');
      try {
        const listStr = (legalHumanMoves || []).join(' ');
        logLine('Legal (board-space) list: ' + listStr);
        if (debugLogging) console.log('[ui] legals list', listStr);
      } catch {}
      renderBoard();
    }

    // General-purpose FEN move applier (handles EP + castling rook relocation)
    function fenApplyUciMove(fen, uci) {
      try {
        if (!fen || !uci || uci.length < 4) return null;
        const parts = fen.trim().split(/\s+/);
        if (parts.length < 6) return null;
        const placement = parts[0];
        const side = parts[1];
        const cast = parts[2];
        const ep = parts[3];
        const half = parts[4];
        let full = parseInt(parts[5], 10) || 1;
        const from = uci.slice(0,2);
        const to = uci.slice(2,4);
        const promo = uci.length > 4 ? uci.slice(4) : '';
        function sqToCoords(sq){ if(!sq||sq.length!==2) return null; const f=sq.charCodeAt(0)-97; const r=sq.charCodeAt(1)-49; if(f<0||f>7||r<0||r>7) return null; return {r:7-r,c:f}; }
        function parseBoard(p){ const ranks=p.split('/'); const b=Array.from({length:8},()=>Array(8).fill('.')); for(let rr=0; rr<8; rr++){ let cc=0; for(const ch of ranks[rr]){ if(/^[1-8]$/.test(ch)){ cc+=parseInt(ch,10);} else { if(cc<8) b[rr][cc++]=ch; } } } return b; }
        function encodeBoard(b){ const out=[]; for(let rr=0; rr<8; rr++){ let row=''; let empty=0; for(let cc=0; cc<8; cc++){ const p=b[rr][cc]; if(p==='.') empty++; else { if(empty){ row+=String(empty); empty=0;} row+=p; } } if(empty) row+=String(empty); out.push(row);} return out.join('/'); }
        function stripCastlingForSide(castStr, stm){ if(!castStr || castStr==='-') return '-'; let filtered=''; for(const ch of castStr){ if(stm==='w'){ if(!(ch>='A' && ch<='Z')) filtered+=ch; } else { if(!(ch>='a' && ch<='z')) filtered+=ch; } } return filtered || '-'; }
        const board=parseBoard(placement);
        const fromC=sqToCoords(from); const toC=sqToCoords(to);
        if(!fromC||!toC) return null;
        const piece=board[fromC.r][fromC.c]; if(piece==='.') return null;

        // Detect castling (king move on same rank to c- or g-file). Handles Standard and Chess960.
        const isKing = piece.toLowerCase()==='k';
        const isSameRank = fromC.r===toC.r;
        const isCastleDest = (toC.c===6 || toC.c===2);
        if (isKing && isSameRank && isCastleDest) {
          const moverIsWhite = (piece===piece.toUpperCase());
          const r = fromC.r;
          const rookChar = moverIsWhite ? 'R' : 'r';
          const isKingside = (toC.c===6);
          const rookDestC = isKingside ? 5 : 3; // f or d
          // Find participating rook on the appropriate side of the king
          let rookOrigC = null;
          if (isKingside) {
            for (let c = 7; c > fromC.c; c--) {
              if (board[r][c] === rookChar) { rookOrigC = c; break; }
            }
          } else {
            for (let c = fromC.c - 1; c >= 0; c--) {
              if (board[r][c] === rookChar) { rookOrigC = c; break; }
            }
          }
          // Move king and rook
          board[fromC.r][fromC.c] = '.';
          board[toC.r][toC.c] = piece;
          if (rookOrigC !== null) {
            board[r][rookOrigC] = '.';
          }
          board[r][rookDestC] = rookChar;

          const newPlacement = encodeBoard(board);
          const newSide = side==='w' ? 'b':'w';
          const newCast = stripCastlingForSide(cast, side);
          let epOut = '-';
          if(side==='b') full += 1; // increment after black move
          try { logLine('fenApplyUciMove: CASTLING applied ' + from + to + ' -> placement=' + newPlacement); } catch {}
          try { if (debugLogging) console.log('[ui] fenApplyUciMove CASTLE', { uci, from, to, newPlacement }); } catch {}
          return `${newPlacement} ${newSide} ${newCast} ${epOut} ${half} ${full}`;
        }

        // Detect en passant capture: pawn moves diagonally to ep target and destination is empty
        const isPawn = piece.toLowerCase()==='p';
        const diagMove = fromC.c!==toC.c;
        const isEpTarget = (ep && ep!=='-' && ep===to);
        if (isPawn && diagMove && isEpTarget && board[toC.r][toC.c]==='.') {
          const moverIsWhite = (piece===piece.toUpperCase());
          const capR = toC.r + (moverIsWhite ? 1 : -1);
          const capC = toC.c;
          if (capR>=0 && capR<8) board[capR][capC]='.'; // remove the passed pawn
        }

        // Move piece and apply promotion if any
        board[fromC.r][fromC.c]='.';
        const placed = promo ? (side==='w'?promo.toUpperCase():promo.toLowerCase()) : piece;
        board[toC.r][toC.c]= placed;

        // Compute en passant target for next move: only after a double pawn push
        let epOut = '-';
        if (isPawn && Math.abs(toC.r - fromC.r)===2) {
          const midR = (toC.r + fromC.r)/2;
          epOut = String.fromCharCode(97 + fromC.c) + String.fromCharCode(49 + (7-midR));
        }

        const newPlacement=encodeBoard(board);
        const newSide = side==='w' ? 'b':'w';
        if(side==='b') full += 1; // increment after black move
        // If king moved (non-castling), strip that side's castling rights as a minimal correctness update
        let newCast = cast;
        if (isKing) newCast = stripCastlingForSide(cast, side);
        return `${newPlacement} ${newSide} ${newCast} ${epOut} ${half} ${full}`;
      } catch(e){ logLine('fenApplyUciMove error: '+e); return null; }
    }
  </script>
  <script>
    // Chess960 generator with X-FEN castling letters
    function generateChess960Start() {
      function randInt(n){ return Math.floor(Math.random() * n); }
      const files = Array.from({length:8}, (_,i)=>i);
      const back = new Array(8).fill(null);
      // Bishops on opposite colors: even and odd files
      const evenFiles = [0,2,4,6];
      const oddFiles = [1,3,5,7];
      const b1 = evenFiles[randInt(evenFiles.length)];
      back[b1] = 'B'; files.splice(files.indexOf(b1),1);
      const b2 = oddFiles[randInt(oddFiles.length)];
      back[b2] = 'B'; files.splice(files.indexOf(b2),1);
      // Queen
      const qIdx = files[randInt(files.length)];
      back[qIdx] = 'Q'; files.splice(files.indexOf(qIdx),1);
      // Knights (two)
      const n1 = files[randInt(files.length)]; back[n1] = 'N'; files.splice(files.indexOf(n1),1);
      const n2 = files[randInt(files.length)]; back[n2] = 'N'; files.splice(files.indexOf(n2),1);
      // Remaining three slots: place rooks at min/max, king in the middle to ensure king between rooks
      files.sort((a,b)=>a-b);
      const rL = files[0], kF = files[1], rR = files[2];
      back[rL] = 'R'; back[kF] = 'K'; back[rR] = 'R';
      // Build rows
      const rowWhite = back.map(ch=>ch||'.').join('').replace(/\.+/g, m=>String(m.length));
      const rowBlack = back.map(ch=>ch.toLowerCase()).join('').replace(/\.+/g, m=>String(m.length));
      const pawnsWhite = 'PPPPPPPP';
      const pawnsBlack = 'pppppppp';
      const empty = '8';
      const placement = [rowBlack, pawnsBlack, empty, empty, empty, empty, pawnsWhite, rowWhite].join('/');
      // X-FEN castling letters: rook files for both sides
      const wRookFiles = [rL, rR];
      const bRookFiles = [rL, rR]; // symmetric file indices for black
      const castWhite = wRookFiles.map(f=>String.fromCharCode(65 + f)).join('');
      const castBlack = bRookFiles.map(f=>String.fromCharCode(97 + f)).join('');
      const castling = (castWhite + castBlack) || '-';
      return `${placement} w ${castling} - 0 1`;
    }
  </script>
  <script>
    // Prefer server-native engine when running from our Express server
    (function(){
      const SERVER_HEALTH = '/engine/health';
      const CHOOSE_URL = '/engine/choose';
      const LEGAL_URL = '/engine/legal';
      function patchToServerNative(){
        if (!window.EngineBridge || window.EngineBridge._serverNativePatched) return;
        const originalChoose = window.EngineBridge.chooseBestMove && window.EngineBridge.chooseBestMove.bind(window.EngineBridge);
        const originalList = window.EngineBridge.listLegalMoves && window.EngineBridge.listLegalMoves.bind(window.EngineBridge);
        const originalApply = window.EngineBridge.applyMoveIfLegal && window.EngineBridge.applyMoveIfLegal.bind(window.EngineBridge);
        function chooseViaServerNative(fen, optionsJson){
          try {
            let depth = 2;
            try { if (optionsJson) { const opts = JSON.parse(optionsJson); depth = (opts.searchDepth||opts.depth||2)|0; } } catch{}
            const xhr = new XMLHttpRequest();
            xhr.open('POST', CHOOSE_URL, false); // synchronous to match existing UI expectations
            xhr.setRequestHeader('Content-Type', 'application/json');
            xhr.send(JSON.stringify({ fen, depth }));
            if (xhr.status >= 200 && xhr.status < 300) {
              const r = JSON.parse(xhr.responseText||'{}');
              const uci = (r && typeof r.move === 'string' && r.move.length >= 4) ? r.move : null;
              if (!uci && originalChoose) {
                // Fallback to original JS engine if server returns no move
                return originalChoose(fen, optionsJson);
              }
              const out = {
                depth,
                nodesTotal: (typeof r.nodes === 'number' ? r.nodes : 0),
                best: { uci, score: (typeof r.score === 'number' ? r.score : null) },
                pv: Array.isArray(r.pv) ? r.pv : [],
                status: 'ok',
                explain: { base: null }
              };
              return JSON.stringify(out);
            }
          } catch(e){ /* fallthrough to original */ }
          return originalChoose ? originalChoose(fen, optionsJson) : JSON.stringify({ error: 'no-engine' });
        }
        function listLegalViaServerNative(fen, fromSq, optionsJson){
          try {
            const xhr = new XMLHttpRequest();
            xhr.open('POST', LEGAL_URL, false);
            xhr.setRequestHeader('Content-Type', 'application/json');
            xhr.send(JSON.stringify({ fen }));
            if (xhr.status >= 200 && xhr.status < 300) {
              const r = JSON.parse(xhr.responseText||'{}');
              let moves = Array.isArray(r.moves) ? r.moves : [];
              // Wrap into objects expected by UI, and filter by fromSq if provided
              moves = moves.map(u => ({ uci: String(u), from: String(u).slice(0,2), to: String(u).slice(2,4) }));
              if (fromSq) moves = moves.filter(m => m.from === fromSq);
              return JSON.stringify({ moves });
            }
          } catch(e){ /* fall through */ }
          return originalList ? originalList(fen, fromSq, optionsJson) : JSON.stringify({ moves: [] });
        }
        function applyIfLegalViaServerNative(fen, uci, optionsJson){
          try {
            // Ask native for legal set; only allow if present
            const xhr = new XMLHttpRequest();
            xhr.open('POST', LEGAL_URL, false);
            xhr.setRequestHeader('Content-Type', 'application/json');
            xhr.send(JSON.stringify({ fen }));
            if (xhr.status >= 200 && xhr.status < 300) {
              const r = JSON.parse(xhr.responseText||'{}');
              const arr = Array.isArray(r.moves) ? r.moves : [];
              if (arr.includes(uci)) {
                return originalApply ? originalApply(fen, uci, optionsJson) : null;
              }
              return null; // reject move not in native legal set
            }
          } catch(e){ /* fallback */ }
          // If native unavailable, fall back to original behavior
          return originalApply ? originalApply(fen, uci, optionsJson) : null;
        }
        window.EngineBridge.chooseBestMove = chooseViaServerNative;
        if (window.EngineBridge.listLegalMoves) window.EngineBridge.listLegalMoves = listLegalViaServerNative;
        if (window.EngineBridge.applyMoveIfLegal) window.EngineBridge.applyMoveIfLegal = applyIfLegalViaServerNative;
        window.EngineBridge._serverNativePatched = true;
        try { document.getElementById('engineSideLabel').textContent = 'white (native-server)'; } catch{}
        console.log('[engine] Using server-native engine by default');
      }
      // Probe server health with a short timeout, then patch EngineBridge
      (function probeAndPatch(){
        try {
          const ctrl = new AbortController();
          const t = setTimeout(()=>ctrl.abort(), 500);
          fetch(SERVER_HEALTH, { method:'GET', signal: ctrl.signal }).then(res=>{
            clearTimeout(t);
            if (res && res.ok) patchToServerNative();
          }).catch(()=>{/* ignore: stay on JS path */});
        } catch {/* ignore */}
      })();
    })();
  </script>
</body>

</html>